#+title: Literate Programming Build System
#+PROPERTY: header-args :noweb no-export

We use [[https://github.com/listx/lilac][Lilac]] for literate programming.

* Weaving (generating the docs)

#+name: Makefile
#+caption: Makefile
#+begin_src makefile :tangle Makefile :eval no
PROJ_ROOT := $(shell git rev-parse --show-toplevel)
LILAC_ROOT := $(PROJ_ROOT)/deps/elisp/lilac
PROCS := $(shell nproc)
define run_emacs
	LILAC_ROOT=$(LILAC_ROOT) emacs $(2) --quick --batch --kill \
		--load $(LILAC_ROOT)/lilac.el \
		--load $(PROJ_ROOT)/codex.el \
		--eval="$(1)"
endef
src = $(shell find problem/ -type f -name '*.org')
src_appendix = $(shell find appendix/ -type f -name '*.org')
woven_html = $(patsubst problem/%.org, problem/%.html, $(src)) \
	$(patsubst appendix/%.org, appendix/%.html, $(src_appendix))
# problem/foo problem/bar ...
problem_dirs = $(shell find problem -maxdepth 1 -type d | sort | tail -n+2)
appendix_dirs = $(shell find appendix -maxdepth 1 -type d | sort | tail -n+2)
# foo bar ...
problem_dirs_without_prefix = $(subst problem/,,$(problem_dirs))
appendix_dirs_without_prefix = $(subst appendix/,,$(appendix_dirs))

define weave_org

$(1): $(2) build-literate.org
	@echo weaving $(2)
	$(call run_emacs,(lilac-publish),$(2))

endef

all: check weave
.PHONY: all

__NREF__Makefile-tangle

weave: build-html

build-html: README.html $(woven_html)
.PHONY: build-html
.PHONY: appendix/mathematics/twos-complement.html

appendix/mathematics/README.html: appendix/mathematics/twos-complement.org
	$(call weave_org,\
	appendix/mathematics/README.html,\
	appendix/mathematics/README.org)

README.html syntax-highlighting.css &: build-literate.org README.org citations.bib
	$(call run_emacs,(lilac-gen-css-and-exit),README.org)
	$(call run_emacs,(lilac-publish),README.org)

$(foreach d,$(appendix_dirs_without_prefix),\
	$(eval $(call weave_org,\
	appendix/$(d)/README.html,\
	appendix/$(d)/README.org)))

$(foreach d,$(problem_dirs_without_prefix),\
	$(eval $(call weave_org,\
	problem/$(d)/README.html,\
	problem/$(d)/README.org)))

check: lint test
.PHONY: check

test: tangle
	python -m unittest discover -s problem
	touch test

lint: mypy ruff
.PHONY: lint

mypy: tangle
	mypy problem
.PHONY: mypy

ruff: tangle
	ruff problem
.PHONY: ruff

# Enter development environment.
shell:
	nix-shell --pure

__NREF__Makefile-update-deps
#+end_src

** Use =lilac.theme= file

First we track Lilac as a submodule within this project, and then symlink to the
CSS, JS, and theme files to the project root. Symlinking adds a level of
indirection such that if we ever decide to move around the submodule location to
somewhere else, we won't have to update all of our Org files and can instead
just update these symlinks.

Then in all of our published Org files, we do

#+begin_src org
#+SETUPFILE: path/to/lilac.theme
#+end_src

to get the CSS/JS that comes with Lilac.

** Custom CSS and HTML <head> content

We tweak Lilac's default CSS a bit.

Make all HTML files we generate try to pull in a local file called
=codex.css=, as well as a custom font.

#+name: __NREF__codex-html-head
#+begin_src emacs-lisp
; See https://stackoverflow.com/a/27285582/437583.
(setq lilac-html-head
      (concat
       "<link rel=\"stylesheet\" type=\"text/css\" href=\"codex.css\" />\n"
       "<link rel=\"stylesheet\" href="
        "\"https://fonts.googleapis.com/css2"
        "?family=Bungee+Shade:wght@400"
       "\">"
       ))
#+end_src

Now supply the default =codex.css= file. This makes the title font bigger and
use a more ornate font for it.

#+name: codex.css
#+caption: codex.css
#+begin_src css :tangle codex.css
h1.title {
    font-family: "Bungee Shade", serif;
    font-size: 100pt;
}
#+end_src

This is a second CSS file where we customize the title text of the pages for the
problems. We just (manually) create a symlink from the problem page's
=codex.css= to this one (because we don't want to use the regular =codex.css=
from above).

#+name: codex.problems.css
#+caption: codex.problems.css
#+begin_src css :tangle codex.problem.css
h1.title {
    font-family: "Source Serif Pro", serif;
}
#+end_src

** Ignore woven HTML from =git diff=

Typically we only need to look at the rendered HTML output in a web browser as
the raw HTML diff output is extremely difficult to parse as a human. So by
default we ask Git to exclude it from =git diff= by treating them as binary
data.

#+name: .gitattributes
#+caption: .gitattributes
#+begin_src gitattributes :tangle .gitattributes :eval no
,* -diff
,**/*.org diff
,**/.gitattributes diff
,**/.gitmodules diff
,**/.gitignore diff
#+end_src

In order to still show the HTML textual diff, we can run =git diff --text=.

*** =git add -p=

Note that the above setting to treat HTML files as binary data prevents them
from being considered for =git add -p=. In order to add them, use =git add -u=
instead.

** gitignore

#+name: .gitignore
#+caption: .gitignore
#+begin_src gitignore :tangle .gitignore :eval no
,**/__pycache__
,**/*.auctex-auto
,**/*.hypothesis
tangle
test
update-deps
weave
#+end_src

* Tangling (generating the source code)

Tangling is simply the act of collecting the =#+begin_src ... #+end_src= blocks
and arranging them into the various target (source code) files. Every source
code block is given a unique name.

We simply tangle all major =*.org= files in the toplevel Makefile.

#+name: __NREF__Makefile-tangle
#+begin_src makefile
# Currently we don't have any optimizations for tangling, but we still set
# CODEX_LP_QUICK=1 anyway to align with what we do for weave-quick.
$(all_tangled_sources) tangle &: $(src)
	@echo tangling in parallel
	CODEX_LP_QUICK=1 make -C $(PROJ_ROOT) -j$(PROCS) $(all_tangled_sources)
	touch tangle

build_literate_org_output = .gitattributes .gitignore Makefile shell.nix
all_tangled_sources = citations.bib $(build_literate_org_output)\
	appendix/python_tricks/__init__.py \
	appendix/python_tricks/test_python_tricks.py \
	$(foreach p,$(problem_dirs_without_prefix),\
		problem/$(p)/__init__.py problem/$(p)/test_$(p).py)

$(build_literate_org_output) &: build-literate.org
	$(call run_emacs,(org-babel-tangle),build-literate.org)

citations.bib: README.org
	$(call run_emacs,(org-babel-tangle),README.org)

appendix/python_tricks/test_python_tricks.py: appendix/python_tricks/README.org
	$(call run_emacs,(org-babel-tangle),appendix/python_tricks/README.org)

define tangle_tests

$(1) $(2) &: $(3)
	@echo tangling $(3)
	$(call run_emacs,(org-babel-tangle),$(3))

endef

# See https://stackoverflow.com/a/9694782/437583.
$(foreach p,$(problem_dirs_without_prefix),\
	$(eval $(call tangle_tests,\
	problem/$(p)/__init__.py,problem/$(p)/test_$(p).py,\
	problem/$(p)/README.org)))
#+end_src

* Development environment (Nix shell)

This is taken from https://github.com/tweag/haskell-stack-nix-example/blob/b9383e35416a2b0e21fbc97ed079538f9f395b6a/shell.nix#L1.

This is the main development shell and brings in all of our dependencies to
build all of our code. It's great for development and testing things out (such
as running "make" to re-run any Python tests that have been updated when adding
new problems).

#+name: shell.nix
#+caption: shell.nix
#+begin_src nix :tangle shell.nix :eval no
let
  # Nixpkgs snapshot.
  sources = import ./package/nix/sources.nix;
  # The final "pkgs" attribute with all the bells and whistles of our overlays.
  pkgs = import sources.nixpkgs {};
in

# This is our development shell.
pkgs.mkShell ({
  buildInputs = [
    # Tangling and weaving for Literate Programming.
    pkgs.emacs

    # Misc
    pkgs.git
    pkgs.less

    # Python testing and linting.
    pkgs.python39Packages.hypothesis
    pkgs.python39Packages.mypy
    pkgs.ruff
  ];
})
#+end_src

** Update Nix dependencies

This is based on Lilac's own code for updating Nix dependencies with [[https://github.com/nmattia/niv][=niv=]].

#+name: __NREF__Makefile-update-deps
#+begin_src makefile
nixpkgs_stable_channel := nixos-23.05
update-deps: package/nix/sources.json package/nix/sources.nix
	cd package && niv update nixpkgs --branch $(nixpkgs_stable_channel)
	cd package && niv update
	touch update-deps
#+end_src

* Elisp

#+name: codex.el
#+caption: codex.el
#+begin_src emacs-lisp :tangle codex.el :eval no
; See https://stackoverflow.com/a/27285582/437583.
(defun codex-test-file-name ()
  (concat "test_" (file-name-nondirectory
                   (directory-file-name
                    (file-name-directory (buffer-file-name))))  ".py"))

(setq org-cite-csl-styles-dir
      (concat (getenv "LILAC_ROOT") "/deps/styles/"))

__NREF__codex-html-head
#+end_src
