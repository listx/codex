#+title: Build System for Literate Programming
#+PROPERTY: header-args :noweb no-export

* Overview of how LP is used in this project

Codex is written with [[https://en.wikipedia.org/wiki/Literate_programming][Literate Programming]] (LP) and uses it for both the executables and libraries. All source code is generated by "tangling" the =*.org= (Org) files and these Org files act as the source of truth. Tangling is done by loading these files into Emacs and then running some =org-mode= functions. These Org files are also the source of truth for all HTML documentation (what you are reading now), and similarly the HTML is generated by invoking some functions from =org-mode=. The outputs of both tangling and weaving are checked into version control.

The vast majority of software projects do not use LP, for various reasons. This project is in part an experiment to see just how valid (or invalid) those reasons are.

** Source code blocks: monoblocks and polyblocks

We use noweb-style references, in the form =<<foo>>=, in source code blocks to delegate source code bits to other blocks. In the example below, the =parent-block= refers to 2 other child blocks for its definition.

#+begin_src org
,#+name: parent-block
,#+begin_src bash
echo "Hello from the parent block"
__NREF__child-block-1
__NREF__child-block-2
,#+end_src

...

,#+name: child-block-1
,#+begin_src bash
echo "I am child 1"
,#+end_src

...

,#+header: :noweb-ref child-block-2
,#+begin_src bash
echo -n "I am "
,#+end_src

,#+header: :noweb-ref child-block-2
,#+begin_src bash
echo "child 2"
,#+end_src
#+end_src

This example illustrates the two ways to define a child block: either as a single code block with =#+name: NAME=, or as multiple blocks with =#+header: :noweb-ref NAME=.  In this doc, we call them [[monoblock][monoblocks]] and [[polyblock][polyblocks]] respectively. Polyblocks are concatenated together in the order they appear in the overall Org file; this final concatenated version is what gets inserted into the noweb reference in the parent block.

* Weaving (generating the docs)

Weaving is conceptually simpler than tangling because there is no extra step --- the output is an HTML page and that is something that we can use directly (unlike program source code, which may require additional compilation into a binary, depending on the language). We also limit ourselves to only HTML for simplicity (in particular, we don't have to worry about page breaks).

Weaving for requires the following dependencies:

#+ATTR_HTML: :border 2 :cellpadding 6 :rules all :frame border
| Dependency | Why      | How to install it |
|------------+----------+-------------------|
| GNU Make   |          | ?                 |
| emacs      |          |                   |
| texlive    | Diagrams |                   |
| pdf2svg    | Diagrams |                   |
| inkscape   | Diagrams |                   |

For Codex, we have a top-level =Makefile= so that we can run some =make= commands on the command line (instead of needing to invoke emacs directly).

#+name: Makefile
#+caption: =Makefile=
#+begin_src makefile :tangle Makefile :eval no
PROJ_ROOT := $(shell git rev-parse --show-toplevel)
PROCS := $(shell nproc)
define run_emacs
	emacs $(2) --quick --batch --kill --load $(PROJ_ROOT)/codex.el --eval="$(1)"
endef

all: tangle weave

__NREF__Makefile-tangle

weave: build-html

weave-quick:
	CODEX_LP_QUICK=1 make -C ${PROJ_ROOT} -j$(PROCS) build-html
.PHONY: weave-quick

build-html: README.html

README.html:
	$(call run_emacs,(batch-org-gen-css-and-exit \"README.org\"),)
	$(call run_emacs,(codex-publish),README.org)
	$(call run_emacs,(codex-publish),problem/parity/README.org)

test:
	python -m unittest discover -s problem

.PHONY: all weave README.html

# Enter development environment.
shell:
	nix-shell --pure
#+end_src

** Emacs customizations for HTML export (codex.el)

#+name: codex.el
#+caption: =codex.el=
#+begin_src emacs-lisp :tangle codex.el :eval no
__NREF__codex_dot_el-performance-optimization
__NREF__codex_dot_el-imports
__NREF__codex_dot_el-fix-nondeterminism
__NREF__codex_dot_el-codex-publish
__NREF__codex_dot_el-autogenerate-css
__NREF__codex_dot_el-misc
#+end_src

*** Toplevel publishing function (=codex-publish=)

#+name: __NREF__codex_dot_el-codex-publish
#+begin_src emacs-lisp
; This optimization can be used to crudely speed up weaving time by disabling fontification (no syntax highlighting of source code blocks).
(if (getenv "CODEX_LP_QUICK")
    (progn
      (message "CODEX_LP_QUICK set; invoking some cost-cutting measures")
      (advice-add 'org-html-fontify-code :around #'codex-disable-syntax-highlighting)))

(defun codex-publish ()
  (interactive)
  (codex-publish-1)
  (codex-publish-2))

;; This is here solely to populate the codex-child-HTML_ID-hash-table.
(defun codex-publish-1 ()
  (let (
        __NREF__codex-publish-modify-org
        __NREF__codex-publish-modify-HTML-1
        __NREF__codex-publish-use-css)
    (org-html-export-to-html)))

(defun codex-publish-2 ()
  (let (
        __NREF__codex-publish-modify-org
        __NREF__codex-publish-modify-HTML-2
        __NREF__codex-publish-use-css)
    ;; Debugging
    ;(message "codex-child-HTML_ID-hash-table: %s" codex-child-HTML_ID-hash-table)
    ;(message "codex-org_id-human_id-hash-table: %s" codex-org_id-human_id-hash-table)
    (org-html-export-to-html)))

;; Modify Org buffer
__NREF__smart-source-code-block-captions
__NREF__UID-for-all-headlines
__NREF__UID-for-all-polyblocks

;; Modify HTML
__NREF__codex-html-filter-src-blocks
__NREF__codex-prettify-source-code-captions
__NREF__codex-human-readable-src-block-ids
#+end_src

**** Modify the Org buffer

Here we modify the Org mode buffer, by using =org-export-before-parsing-hook=. This takes a list of functions that are free to modify the Org mode buffer before each Org element in the buffer gets converted into HTML. For now we just give it a single function, =codex-link-child-src-blocks-to-parents=.

#+name: __NREF__codex-publish-modify-org
#+begin_src emacs-lisp
(org-export-before-parsing-hook
 '(codex-smart-source-code-block-captions
   codex-UID-for-all-headlines
   codex-UID-for-all-polyblocks))
#+end_src

**** Modify the HTML

Here we modify the final HTML. This is useful for adding in final tweaks to the HTML that is difficult to accomplish at the Org-mode buffer level.

Phase 1: In the first phase, we use the generated HTML data to populate the =child-HTML_ID-hash-table=. This data structure is used to link to child blocks from parent blocks.

#+name: __NREF__codex-publish-modify-HTML-1
#+begin_src emacs-lisp
(org-export-filter-src-block-functions
 '(codex-populate-child-HTML_ID-hash-table
   codex-populate-org_id-human_id-hash-table))
#+end_src


Phase 2: In this phase we perform the linking from parent blocks to child blocks.

#+name: __NREF__codex-publish-modify-HTML-2
#+begin_src emacs-lisp
(org-export-filter-src-block-functions
 '(codex-link-to-children-from-parent-body
   codex-prettify-source-code-captions))
(org-export-filter-final-output-functions
 '(codex-replace-ord_ids-with-human_ids))
#+end_src

**** Miscellaneous export settings

Do not hardcode colors into the HTML. Instead refer to CSS class names, to be stylized by an external CSS file.

#+name: __NREF__codex-publish-use-css
#+begin_src emacs-lisp
(org-html-htmlize-output-type 'css)
#+end_src

*** Org modifications

**** Smart source code block captions

We want every source code block to have a caption (=#+caption: ...=) to have the following items:

1. [[(SCB_NAME)][=SCB_NAME=]]: name of the source code block,
2. [[(SCB_POLYBLOCK_INDICATOR)][=SCB_POLYBLOCK_INDICATOR=]]: an indicator to show whether this block is broken up over multiple blocks, and
3. [[(SCB_LINK_TO_PARENT)][=SCB_LINK_TO_PARENT=]]: a link back up to a parent block (if any) where this block is used.

Adding these rudimentary items to the caption areas by hand for every source code block would be prohibitively tedious and error-prone. And so, we automate it with some Emacs lisp!

What we want to do is, loop through every source code block and insert a (=#+caption: ...=) text into the buffer. This modified buffer is what is sent down the pipeline for final export to HTML (i.e., the buffer modification does not affect the actual buffer (=*.org= file)).

So assume that we already have the smart captions in a sorted [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html][association list]] (aka alist), where the KEY is the integer buffer position where this caption should be inserted, and the VALUE is the caption itself (a string), like this:

#+begin_src elisp
'((153  . "#+caption: ...")
  (384  . "#+caption: ...")
  (555  . "#+caption: ...")
  (684  . "#+caption: ...")
  (1051 . "#+caption: ..."))
#+end_src

We can use the KEY to go to that buffer position and insert the caption. However the insertion operation mutates the buffer. This means if we perform the insertions top-to-bottom, the subsequent KEY values will become obsolete. The trick then is to just do the insertions in reverse order (bottom-to-top), so that the remaining KEY values remain valid. This is what we do below, where =smart-captions= is an alist like the one just described.

#+name: __NREF__smart-source-code-block-captions
#+begin_src emacs-lisp
(defun codex-smart-source-code-block-captions (_backend)
  (let* ((parent-blocks
           __NREF__parent-blocks)
         (child-parent-hash-table
           __NREF__child-parent-hash-table)
         (all-src-blocks
           __NREF__all-src-blocks)
         (smart-captions
           __NREF__smart-captions))
    (cl-loop for smart-caption in (reverse smart-captions) do
      (let ((pos (car smart-caption))
            (caption (cdr smart-caption)))
        (goto-char pos)
        (insert caption)))))

__NREF__smart-source-code-block-captions-helpers
#+end_src

(We'll get to the helper functions =__NREF__smart-source-code-block-captions-helpers= later as they obscure the big picture.)

Now we just have to construct =smart-captions=. The main difficulty is the construction of [[(SCB_LINK_TO_PARENT)][=SCB_LINK_TO_PARENT=]], so most of the code will be concerned about child-parent associations.

Why do we even need these source code blocks to link back to their parents? The point is to make things easier to navigate. For example, if we have

#+begin_src org
,#+name: parent-block
,#+begin_src bash
echo "Hello from the parent block"
__NREF__child-block-1
__NREF__child-block-2
,#+end_src

...

,#+name: child-block-1
,#+begin_src bash
echo "I am child 1"
,#+end_src

...

,#+header: :noweb-ref child-block-2
,#+begin_src bash
echo -n "I am "
,#+end_src

,#+header: :noweb-ref child-block-2
,#+begin_src bash
echo "child 2"
,#+end_src
#+end_src

and we export this to HTML, ideally we would want both =child-block-1= and each of the =child-block-2= blocks to include an HTML link back up to =parent-block=. This would make it easier to skim the document and not get too lost (any time you are looking at any particular source code block, you would be able to just click on the lank back to the parent (if there is one) to see a higher-level view).

The key idea here is to build a hash table (=child-parent-hash-table=) where the KEY is a child source code block and the VALUE is the parent block. Then in order to construct [[(SCB_LINK_TO_PARENT)][=SCB_LINK_TO_PARENT=]] we just do a lookup against this hash table to find the parent (if any).

Th first thing we need is a list of parent source code blocks. We consider a source code block a parent block if it has any noweb references within its body.

#+name: __NREF__parent-blocks
#+begin_src emacs-lisp
;; parent-blocks is a let* binding, not a function call.
(org-element-map (org-element-parse-buffer) 'src-block
  (lambda (src-block)
     (if (codex-is-parent-block src-block) src-block)))
#+end_src

Then we construct the =child-parent-hash-table=. For each parent block, we get all of its children (=child-names=), and use this data to construct a child-parent association:

#+name: __NREF__child-parent-hash-table
#+begin_src emacs-lisp
(let ((hash-table (make-hash-table :test 'equal)))
  (mapc
   (lambda (parent-block)
    (let* ((parent-name (org-element-property :name parent-block))
           (parent-body (org-element-property :value parent-block))
           (child-names (codex-get-noweb-children parent-body)))
      (mapc (lambda (child-name) (puthash child-name parent-name hash-table)) child-names)))
   parent-blocks)
  hash-table)
#+end_src

#+begin_src emacs-lisp
(make-hash-table :test 'equal)
(apply 'make-hash-table ':test 'equal
  (mapcan (lambda (parent-name)
            (mapcan (lambda (child-name) (list child-name 1)) '('c1 'c2 'c3))) '(p1 p2)))
#+end_src

Now that we have the child-parent associations, we have to look at all source code blocks and check if

1. this source code block's name shows up at all in =child-parent-hash-table=, and if so
2. add a link to the parent.

Note that a child source block can have two ways of defining its name. The first is with the direct =#+name: NAME= line, and the second way is with a line like ="#+header: :noweb-ref NAME"=.

Let's grab all source code blocks:

#+name: __NREF__all-src-blocks
#+begin_src emacs-lisp
(org-element-map (org-element-parse-buffer) 'src-block 'identity)
#+end_src

And now we can finally construct =smart-captions=:

#+name: __NREF__smart-captions
#+begin_src emacs-lisp -r -l ";ref:%s"
(-remove 'null
  (cl-loop for src-block in all-src-blocks collect
    (let* ((child (codex-get-src-block-name src-block))
           (child-name (car child))
           (SCB_NAME (format "=%s= " child-name))                  ;ref:SCB_NAME
           (SCB_POLYBLOCK_INDICATOR (car (cdr child)))             ;ref:SCB_POLYBLOCK_INDICATOR
           (parent (gethash child-name child-parent-hash-table))
           (pos (org-element-property :begin src-block))
           (SCB_LINK_TO_PARENT                                     ;ref:SCB_LINK_TO_PARENT
            (if parent (format " [[%s][PARENT]]" parent) ""))
           (smart-caption
            (concat
              "#+caption: "
              SCB_NAME
              SCB_POLYBLOCK_INDICATOR
              SCB_LINK_TO_PARENT
              "\n")))
      (when parent (cons pos smart-caption)))))
#+end_src

We used some helper functions up in [[__NREF__smart-source-code-block-captions][=__NREF__smart-source-code-block-captions=]]; let's examine them now.

#+name: __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp
__NREF__codex-is-parent-block
__NREF__codex-get-noweb-children
__NREF__codex-get-noweb-ref-name
__NREF__codex-get-src-block-name
#+end_src

=codex-is-parent-block= checks whether a source code block is a parent (contains noweb references to other child blocks in the form =__NREF__child-name=).

#+name: __NREF__codex-is-parent-block
#+begin_src emacs-lisp
(defun codex-is-parent-block (src-block)
  (let ((body (org-element-property :value src-block)))
    (codex-get-noweb-children body)))
#+end_src

=codex-get-noweb-children= extracts all noweb references in the form "=<<NAME>>=" from a given multiline string, returning a list of all such NAMEs. This function expects at most 1 noweb reference per line. The return type is a list of strings.

#+name: __NREF__codex-get-noweb-children
#+begin_src emacs-lisp
(defun codex-get-noweb-children (s)
  (let* ((lines (split-string s "\n"))
         (refs (-remove 'null
                 (mapcar
                  (lambda (line)
                   (if (string-match (codex-nref-rx nil) line)
                       (match-string-no-properties 1 line)))
                  lines))))
    refs))
#+end_src

=codex-get-noweb-ref-name= gets the string =FOO= in a =#+header: :noweb-ref FOO= line for a source code block.

#+name: __NREF__codex-get-noweb-ref-name
#+begin_src emacs-lisp
(defun codex-get-noweb-ref-name (source-code-block)
  (let* ((headers (org-element-property :header source-code-block))
         (noweb-ref-name
          (nth 0
           (-remove 'null
            (mapcar
             (lambda (header)
               (if (string-match ":noweb-ref \\(.+\\)" header)
                   (match-string-no-properties 1 header)))
             headers)))))
    noweb-ref-name))
#+end_src

=codex-get-src-block-name= grabs the name of a (child) source code block. A child block can either be named directly with the =#+name: NAME= line, or indirectly with =#+header: noweb-ref NAME= (as we saw with =codex-get-noweb-ref-name=). We save the direct/indirect information as string, and this is used as the [[(SCB_POLYBLOCK_INDICATOR)][=SCB_POLYBLOCK_INDICATOR=]].

#+name: __NREF__codex-get-src-block-name
#+begin_src emacs-lisp
(defun codex-get-src-block-name (src-block)
  (let* ((name-direct (org-element-property :name src-block))
         (name-indirect (codex-get-noweb-ref-name src-block)))
    (if name-direct
        `(,name-direct "")
        `(,name-indirect "(polyblock)"))))
#+end_src

**** Human-readable UIDs (Headings, aka headlines)

We want all headings to have HTML IDs that are patterned after their text. This way we can have IDs like =some-heading-name-1= (where the trailing =-1= is only used to disambiguate against another heading of the same name) instead of =org00000a1=.

For each heading, we insert a =CUSTOM_ID= property which takes precedence over the =org...= IDs. We append this headline property just below every headline we find in the buffer. The actual construction of the =CUSTOM_ID= (=headline-UID= in the code below) is done by =codex-get-unique-id=.

#+Name: __NREF__UID-for-all-headlines
#+begin_src emacs-lisp
(defun codex-UID-for-all-headlines (_backend)
  (let* ((all-headlines
           (org-element-map (org-element-parse-buffer) 'headline 'identity))

         (headline-uid-hash-table (make-hash-table :test 'equal))
         (headline-UIDs
           (-remove 'null
             (cl-loop for headline in all-headlines collect
               (let* ((headline-UID (codex-get-unique-id headline headline-uid-hash-table))
                      ;; Get the position just after the headline (just underneath it).
                      (pos (progn
                             (goto-char (org-element-property :begin headline))
                             (re-search-forward "\n"))))
                 (cons pos (concat
                            ":PROPERTIES:\n"
                            ":CUSTOM_ID: " headline-UID "\n"
                            ":END:\n")))))))
    ; (message "custom ID insertions: %s" headline-UIDs)
    (cl-loop for pos-insertion in (reverse headline-UIDs) do
        (let ((pos (car pos-insertion))
              (insertion (cdr pos-insertion)))
            (goto-char pos)
            (insert insertion)))))

__NREF__get-unique-id
#+end_src

=codex-get-unique-id= converts a given headline to its canonical form (every non-word character converted to a dash) and performs a lookup against the hash table. If the entry exists, it looks up a =entry-N= value in a loop with =N= increasing until it sees that no such key exists.

#+name: __NREF__get-unique-id
#+begin_src emacs-lisp
(defun codex-get-unique-id (headline hash-table)
  (let* ((name (org-element-property :raw-value headline))
         (disambiguation-number 0)
         (key (concat "h-" (codex-normalize-string name)))
         (val (gethash key hash-table)))
    ;; Discard the key if a value already exists. This drives up the
    ;; disambiguation number.
    (while val
      (setq disambiguation-number (+ 1 disambiguation-number))
      (setq key (concat "h-"
                        (codex-normalize-string
                         (format "%s-%s" name disambiguation-number))))
      (setq val (gethash key hash-table)))
    (puthash key t hash-table)
    key))

(defun codex-normalize-string (s)
  (string-trim
    (replace-regexp-in-string "[^A-Za-z0-9]" "-" s)
    "-"
    "-"))
#+end_src

**** Give polyblocks a =#+name: ...= field (HTML ID)

Only source code blocks that have a =#+name: ...= field (org name field) get an HTML ID (org ID) assigned to it. The problem with polyblocks is that they are not assigned an org name field by default.

Of course, we still want all polyblock to have an HTML ID, which can then be extracted by [[(codex-get-src-block-HTML_ID)][=codex-get-src-block-HTML_ID=]] to build up the =child-HTML_ID-hash-table= in [[* Link noweb references (link to child block from parent block)]]. If we don't do this then parent source code blocks won't be able to link to the polyblock at all.

(Monoblocks with a =#+name: ...= field get a unique HTML ID assigned to it in the form =orgN= where =N= is a hexadecimal number. By default Org generates a random number for =N=, but we use a simple counter that increments, starting from 0 (see [[*Do not use random numbers for the HTML "id" attribute]]).)

What we can do is inject a =#+name: ___polyblock-N= line (where =N= is an incrementing number) into the beginning of the source code section of all polyblocks. Then we can construct an HTML link to any polyblock.

Note that we only name the first polyblock in the set of polyblocks that share the same noweb-ref. This is so that we link to the first polyblock child from the parent block (because the assumption is that we will want to start reading about this set of polyblocks beginning with the first block).

#+name: __NREF__UID-for-all-polyblocks
#+begin_src emacs-lisp
(defun codex-UID-for-all-polyblocks (_)
  (let* ((all-src-blocks
           __NREF__all-src-blocks)
         (polyblock-id 0)
         (noweb-ref-last "")
         (polyblock-UIDs
           (-remove 'null
             (cl-loop for src-block in all-src-blocks collect
               (let* ((noweb-ref (codex-get-noweb-ref-name src-block))
                      (is-polyblock
                       (and
                         noweb-ref
                         (not (org-element-property :name src-block))))
                      (pos (org-element-property :begin src-block))
                      (name-field-with-uid (format "#+name: ___polyblock-%s\n" polyblock-id)))
                 (when (and
                         is-polyblock
                         (not (string= noweb-ref noweb-ref-last)))
                   (setq noweb-ref-last noweb-ref)
                   (setq polyblock-id (+ 1 polyblock-id))
                   (cons pos name-field-with-uid)))))))
    (cl-loop for polyblock-UID in (reverse polyblock-UIDs) do
        (let ((pos (car polyblock-UID))
              (name-field-with-uid (cdr polyblock-UID)))
            (goto-char pos)
            (insert name-field-with-uid)))))
#+end_src

*** HTML modifications

**** Use human-readable HTML IDs for source code links

Recall that there are 2 types of source code blocks: [[monoblock][monoblocks]] and [[polyblock][polyblocks]].

Polyblocks do get a name field attached to them during the [[*Give polyblocks a =#+name: ...= field (HTML ID)][Org modification stage]], in the format =___polyblock-N=. These names are for HTML link generation only, because the user won't see them --- they will instead just see =org000012= or some such. In fact, all monoblocks are also given these random-looking (and unstable) =org...= HTML IDs.

And therein lies the problem: if a user decides to bookmark a particular source code block, whether a monoblock or polyblock, they will link to an =org...=-style ID and chances are that this link will break over time.

This is exactly the same problem we have for headlines. For headlines we solved the problem with a [[* Human-readable UIDs (Headings, aka headlines)][hash table]], and we need to do the same thing here. The major difference, though, is that unlike headlines which can accept a =CUSTOM_ID= Org property, source code blocks have no such facility. So instead of modifying the buffer (as we do for headlines), we have to modify the final HTML output instead.

The solution is to simply look at all source code block links, then modify the ~id=...~ part so that it looks like a more human-readable ID. We can extract the human-readable ID by looking at the smart captions inside the =<label>...</label>= area for both monoblocks and polyblocks. And then it's just a matter of doing a basic search-and-replace across the entire buffer (HTML file).

We have to do a search-and-replace across the entire file because we may also have manual links to source code blocks (although --- maybe it's just not worth it because we can't refer to polyblocks anyway by name).

#+name: __NREF__codex-human-readable-src-block-ids
#+begin_src emacs-lisp -r -l ";ref:%s"
; Define a global hash table for mapping Org-mode-generated ids (that look like "org00012") for source code blocks to a more human-readable ID.
(setq codex-org_id-human_id-hash-table (make-hash-table :test 'equal))

(defun codex-populate-org_id-human_id-hash-table (src-block-html backend info)
  (when (org-export-derived-backend-p backend 'html)
    (let* ((block-name (codex-get-src-block-name-from-html src-block-html))
           (orgid (codex-get-src-block-HTML_ID src-block-html)))
      (when orgid
        (puthash orgid block-name codex-org_id-human_id-hash-table))
      src-block-html)))

(defun codex-replace-ord_ids-with-human_ids (entire-html backend info)
  (when (org-export-derived-backend-p backend 'html)
    (let ((html-oneline (codex-to-single-line entire-html)))
      (maphash
       (lambda (k v)
        (when (and k v)
         (setq html-oneline
               (replace-regexp-in-string
                (rx-to-string `(and " id=" (* (not "\"")) "\"" ,k "\""))
                (format " id=\"%s\"" v) html-oneline))
         (setq html-oneline
               (replace-regexp-in-string
                (rx-to-string `(and " href=" (* (not "\"")) "\"#" ,k "\""))
                (format " href=\"#%s\"" v) html-oneline))))
       codex-org_id-human_id-hash-table)
      (codex-to-multi-line html-oneline))))
#+end_src

**** Pretty source code captions

Here there are basically 3 things we have to keep track of:

1. the outer =<div>= that encloses the entire source code block,
2. the =<label>=, if any (it may not exist), and
3. the =<pre>= content.

We only care about source code blocks with a =<label>= because that determines whether we have a "Listing: ..." or not. We just need to save the 3 bits of information, and then:

1. print the outer =<div ...>=,
2. print the =<pre>= content, and
3. print the =<label>= content but as a =<div>=.

For the last step, we want to additionally parse the inner "Listing N ... PARENT-link" text and transform it with reordering and also additional metadata information such as ~<span class="...">~ tags.

#+name: __NREF__codex-prettify-source-code-captions
#+begin_src emacs-lisp
(defun codex-prettify-source-code-captions (src-block-html backend info)
  (when (org-export-derived-backend-p backend 'html)
    ;; Break up source block into 3 subparts --- the leading <div ...>, the <label ...></label> (if any) and
    ;; <pre ...></pre>.
    ;; Then run the linkifying logic against only the body, and then return the
    ;; original label and new body.
    (let* ((div-caption-body (codex-get-source-block-html-parts-without-newlines src-block-html))
           (leading-div (nth 0 div-caption-body))
           (body (nth 2 div-caption-body))
           (pre-id-match
             (string-match
               (rx-to-string
                 '(and
                       "<pre "
                       (* (not ">"))
                       "id=\""
                       (group (+ (not "\"")))))
               body))
           (pre-id
             (if pre-id-match
                 (match-string-no-properties 1 body)
                 "#deadlink"))
           (body-with-newlines
            (codex-to-multi-line body))
           (caption (nth 1 div-caption-body))
           (caption-parts
             (let* ((caption-match
                      (string-match "<label [^>]+>\\(.*?\\)</label>" caption)))
               (if caption-match
                   (match-string-no-properties 1 caption)
                   "")))
           (source-block-name-match
             (string-match
               (rx-to-string
                 '(and
                       "<code>"
                       (group (+ (not "<")))
                       "</code>"))
               caption-parts))
           (source-block-name
             (if source-block-name-match
                 (match-string-no-properties 1 caption-parts)
                 ""))
           (source-block-name-styled
             (cond ((string-prefix-p "__NREF__" source-block-name)
                    (concat
                      "<span class=\"codex-caption-source-code-block-name\">"
                      "&#x1f33f; "
                      (string-remove-prefix "__NREF__" source-block-name)
                      "</span>"))
                   (t
                    (concat
                      "<span class=\"codex-caption-source-code-block-name\">"
                      "&#x1f4c4; "
                      source-block-name
                      "</span>"))))
           (parent-id-match
             (string-match
               (rx-to-string
                 '(and
                       " <a href=\""
                       (group (+ (not "\"")))))
               caption-parts))
           (parent-id
             (if parent-id-match
                 (format "<span class=\"codex-caption-parent-link\"><a href=\"%s\">PARENT</a></span>"
                   (match-string-no-properties 1 caption-parts))
                 ""))
           (listing-number-match
             (string-match
               (rx-to-string
                 '(and "Listing "
                       (group (+ (any digit)))))
               caption-parts))
           (listing-number
             (if listing-number-match
                 (format "<span class=\"codex-caption-listing-number\"><a href=\"#%s\">#%s</a></span>"
                   pre-id
                   (match-string-no-properties 1 caption-parts))
                 "")))
      (if (s-blank? caption)
       src-block-html
       (concat
        leading-div
        "<div class=\"codex-pre-with-caption\">"
        body-with-newlines
        "</div>"
        "<div class=\"codex-caption\">"
        source-block-name-styled
        parent-id
        listing-number
        "</div>"
        "</div>")))))

__NREF__codex-get-source-block-html-parts-without-newlines
#+end_src

This is a helper function to parse the HTML output for a source code block.

#+name: __NREF__codex-get-source-block-html-parts-without-newlines
#+begin_src emacs-lisp
(defun codex-get-source-block-html-parts-without-newlines (src-block-html)
    (let* ((one-line (codex-to-single-line src-block-html))
           (leading-div
             (let ((div-match
                    (string-match "<div [^>]+>" one-line)))
               (match-string-no-properties 0 one-line)))
           (caption
             (let* ((caption-match
                      (string-match "<label [^>]+>.*?</label>" one-line)))
               (if caption-match
                   (match-string-no-properties 0 one-line)
                   "")))
           (body (progn (string-match "<pre [^>]+>.*?</pre>" one-line)
                        (match-string-no-properties 0 one-line))))
      `(,leading-div ,caption ,body)))
#+end_src

**** Link noweb references (link to child block from parent block)

Consider the following code:

#+begin_src org
,#+name: parent-block
,#+begin_src bash
echo "Hello from the parent block"
__NREF__child-block-1
__NREF__child-block-2
,#+end_src

...

,#+name: child-block-1
,#+begin_src bash
echo "I am child 1"
,#+end_src

...

,#+header: :noweb-ref child-block-2
,#+begin_src bash
echo -n "I am "
,#+end_src

,#+header: :noweb-ref child-block-2
,#+begin_src bash
echo "child 2"
,#+end_src
#+end_src

What we want to do is to make the =__NREF__child-block-1= and =__NREF__child-block-2= references inside =parent-block= to link to their definitions, so that the reader can just click on them to go to see how they're defined. Unfortunately Org mode doesn't do this by default so we have to do this ourselves.

In the case of =child-block-2=, it is defined in multiple blocks so we would want to link to the very first block.

We cannot use a =org-export-before-parsing-hook= like we did in [[__NREF__codex-publish-modify-org][=__NREF__codex-publish-modify-org=]] because at that stage of processing, we are dealing with Org mode syntax. Any modifications we make to the parent source code block will be treated as text upon HTML export. Thankfully Org mode allows customizations on generated HTML through the =org-export-filter-src-block-functions= variable. This variable is analogous to =org-export-before-parsing-hook=, but operates at the HTML level (not at the Org syntax level) for source code blocks, which is exactly what we need.

So we have to craft valid HTML links (not Org links) to the child source code blocks. For this we need the actual =id= part of the HTML =<pre>...= block that will hold the source code. That is, the algorithm should be something like:

1. for every parent source code block,
2. for every child block (noweb) referenced in the body, insert an HTML link to the child block (lookup in =child-HTML_ID-hash-table=).

The only thing remaining is the construction of =child-HTML_ID-hash-table=. We can construct this by mapping through all source code blocks and getting the name which can be just drawn from the =<label ...>= HTML tag, thanks to the smart captions we inserted for all child blocks earlier in [[*Smart source code block captions][/Smart source code block captions/]].

#+name: __NREF__codex-html-filter-src-blocks
#+begin_src emacs-lisp -r -l ";ref:%s"
; Define a global hash table for mapping child source block names to their HTML IDs.
(setq codex-child-HTML_ID-hash-table (make-hash-table :test 'equal))

(defun codex-populate-child-HTML_ID-hash-table (src-block-html backend info)
  (when (org-export-derived-backend-p backend 'html)
    (let* ((child-name (codex-get-src-block-name-from-html src-block-html))
           (child-HTML_ID (codex-get-src-block-HTML_ID src-block-html)))
      (if child-HTML_ID ; Skip blocks that lack an HTML ID, such as non-head polyblocks.
        (puthash child-name child-HTML_ID codex-child-HTML_ID-hash-table))
      ; Return src-block-html as-is (no modifications).
      src-block-html)))

(defun codex-get-src-block-name-from-html (src-block-html)
  (let* ((match-nref (string-match
                      (concat
                       "<label.+?<code>"
                       (codex-nref-rx nil)
                       "</code>")
                      src-block-html))
         (match-raw (if (not match-nref)
                        (string-match
                         (rx-to-string
                          '(and
                            "<label"
                            (+ (not ">"))
                            ">"
                            (group (*? anychar))
                            "</label>"))
                         src-block-html)))
         (matched-contents (match-string-no-properties 1 src-block-html)))
    (if match-nref
        matched-contents
        (if match-raw
            (codex-clean-up-match-raw matched-contents)))))

(defun codex-clean-up-match-raw (s)
  (let* ((normalized (codex-normalize-string s))
         (rx (rx-to-string
                '(and
                  "Listing-"
                  (+ (any digit))
                  (+ "-")
                  "span"
                  (* "-")
                  (group (+ anychar)))))
         (match (string-match rx normalized)))
    (if match
        (match-string-no-properties 1 normalized)
        normalized)))

(defun codex-get-src-block-HTML_ID (src-block-html) ;ref:codex-get-src-block-HTML_ID
  (let ((match (string-match "<pre [^>]+?id=\"\\([^\"]+\\)\">" src-block-html)))
    (if match (match-string-no-properties 1 src-block-html))))

(defun codex-link-to-children-from-parent-body (src-block-html backend info)
  (when (org-export-derived-backend-p backend 'html)
    ;; Break up source block into 3 subparts --- the leading <div ...>, the <label ...></label> (if any) and
    ;; <pre ...></pre>.
    ;; Then run the linkifying logic against only the body, and then return the
    ;; original label and new body.
    (let* ((div-caption-body (codex-get-source-block-html-parts-without-newlines src-block-html))
           (leading-div (nth 0 div-caption-body))
           (caption (nth 1 div-caption-body))
           (body (nth 2 div-caption-body))
           (body-linkified-without-newlines
            (replace-regexp-in-string
             (codex-nref-rx nil)
             (lambda (child-name-text)
                 (let* ((HTML_ID (gethash child-name-text codex-child-HTML_ID-hash-table)))
                  (if HTML_ID
                      (concat "<span class=\"codex-child-link-from-parent\"><a href=\"#" HTML_ID "\">"
                              (string-remove-prefix "__NREF__" child-name-text)
                              "</a></span>")
                      child-name-text)))
             body))
           (body-linkified-with-newlines
            (codex-to-multi-line body-linkified-without-newlines)))
      (concat leading-div caption body-linkified-with-newlines "</div>"))))

(defun codex-to-single-line (s)
  (replace-regexp-in-string "\n" "<<<NEWLINE>>>" s))

(defun codex-to-multi-line (s)
  (replace-regexp-in-string "<<<NEWLINE>>>" "\n" s))

__NREF__custom-noweb-delimiters
__NREF__babel-load-languages
__NREF__evaluate-all-blocks
#+end_src

Note that we need to evaluate this lisp code if we want to run ~C-c C-v t~ to tangle code blocks properly in an interactive manner from an Emacs editing session.

FIXME: Evaluate this snippet of code when loading this file for editing purposes?

#+name: __NREF__custom-noweb-delimiters
#+begin_src emacs-lisp :noweb no
(setq org-babel-noweb-wrap-start "__NREF__")
(setq org-babel-noweb-wrap-end "")

(defun codex-nref-rx (match-optional-params)
  (rx-to-string
   (codex-nref-rx-primitive match-optional-params)))

(defun codex-nref-rx-primitive (match-optional-params)
  (if match-optional-params
   `(group
           "__NREF__"
          (any alpha) ;; Noweb reference must start with a letter...
          ;; ...and must be followed by letters,numbers,dashes,underscores,periods...
          (* (or (any alnum) "-" "_" "."))
          ;; ...and may terminate with a "(...)" where the "..." may be an empty string, or some other argument.
          (* (or "()"
                 (and "("
                      (* (not ")"))
                      ")"))))
   `(group
          "__NREF__"
          (any alpha)
          (* (or (any alnum) "-" "_" ".")))))

;; We only use starting delimiters. All of them start with comment characters recognized by various languages, exept for "__NREF__". This last one is a catch-all in case we want to inject a noweb reference on a line with some trailing content (because we cannot do ";; NREF: foo)" --- notice the trailing parentheses --- in elisp, because parinfer destroys it during an editing session).
;; See https://emacs.stackexchange.com/a/73720/13006. Customize noweb delimiters.
(defun org-babel-noweb-wrap (&optional regexp)
  "Return regexp matching a Noweb reference.

Match any reference, or only those matching REGEXP, if non-nil.
When matching, reference is stored in match group 1."
  (codex-nref-rx t))
#+end_src

We need to do this; otherwise we cannot evaluate any source code blocks during weaving (while running emacs from the command line in batch mode).

#+name: __NREF__babel-load-languages
#+begin_src emacs-lisp
;(org-babel-do-load-languages
; 'org-babel-load-languages '((shell . t)))
#+end_src

#+name: __NREF__evaluate-all-blocks
#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+end_src

*** Autogenerate CSS for syntax highlighting of source code blocks

See https://emacs.stackexchange.com/questions/31439/how-to-get-colored-syntax-highlighting-of-code-blocks-in-asynchronous-org-mode-e, specifically https://emacs.stackexchange.com/a/36759.

Generate =syntax-highlighting.css= and quit emacs. This function is designed to be run from the command line on a fresh emacs instance (dedicated OS process). Unfortunately, by itself it is almost useless (see [[__NREF__enable-syntax-highlighting-from-batch-mode][=__NREF__enable-syntax-highlighting-from-batch-mode=]]).

#+name: __NREF__codex_dot_el-autogenerate-css
#+begin_src emacs-lisp
(defun batch-org-gen-css-and-exit (org-file)
  (find-file org-file)
  (font-lock-flush)
  (font-lock-fontify-buffer)
  (org-html-htmlize-generate-css)
  (with-current-buffer "*html*"
    (write-file "syntax-highlighting.css"))
  (kill-emacs))

;; Without this, batch-org-gen-css-and-exit produces a near-empty CSS file.
__NREF__enable-syntax-highlighting-from-batch-mode
#+end_src

Sadly, =batch-org-gen-css-and-exit= by itself generates a near-blank CSS file. So we have to use code from https://emacs.stackexchange.com/questions/38437/org-mode-batch-export-missing-syntax-highlighting:

#+name: __NREF__enable-syntax-highlighting-from-batch-mode
#+begin_src emacs-lisp
(require 'font-lock)
(require 'subr-x) ;; for `when-let'

(unless (boundp 'maximal-integer)
  (defconst maximal-integer (lsh -1 -1)
    "Maximal integer value representable natively in emacs lisp."))

(defun face-spec-default (spec)
  "Get list containing at most the default entry of face SPEC.
Return nil if SPEC has no default entry."
  (let* ((first (car-safe spec))
     (display (car-safe first)))
    (when (eq display 'default)
      (list (car-safe spec)))))

(defun face-spec-min-color (display-atts)
  "Get min-color entry of DISPLAY-ATTS pair from face spec."
  (let* ((display (car-safe display-atts)))
    (or (car-safe (cdr (assoc 'min-colors display)))
    maximal-integer)))

(defun face-spec-highest-color (spec)
  "Search face SPEC for highest color.
That means the DISPLAY entry of SPEC
with class 'color and highest min-color value."
  (let ((color-list (cl-remove-if-not
             (lambda (display-atts)
               (when-let ((display (car-safe display-atts))
                  (class (and (listp display)
                          (assoc 'class display)))
                  (background (assoc 'background display)))
             (and (member 'light (cdr background))
                  (member 'color (cdr class)))))
             spec)))
    (cl-reduce (lambda (display-atts1 display-atts2)
         (if (> (face-spec-min-color display-atts1)
            (face-spec-min-color display-atts2))
             display-atts1
           display-atts2))
           (cdr color-list)
           :initial-value (car color-list))))

(defun face-spec-t (spec)
  "Search face SPEC for fall back."
  (cl-find-if (lambda (display-atts)
        (eq (car-safe display-atts) t))
          spec))

; This is slightly tweaked from the original, because the incoming "face" value can look like (fixed-pitch face-name) --- so we take the second element.
(defun my-face-attribute (face attribute &optional frame inherit)
  "Get FACE ATTRIBUTE from `face-user-default-spec' and not from `face-attribute'."
  (let* ((face-spec (face-user-default-spec (if (listp face) (car (cdr face)) face)))
     (display-attr (or (face-spec-highest-color face-spec)
               (face-spec-t face-spec)))
     (attr (cdr display-attr))
     (val (or (plist-get attr attribute) (car-safe (cdr (assoc attribute attr))))))
    ;; (message "attribute: %S" attribute) ;; for debugging
    (when (and (null (eq attribute :inherit))
           (null val))
      (let ((inherited-face (my-face-attribute face :inherit)))
    (when (and inherited-face
           (null (eq inherited-face 'unspecified)))
      (setq val (my-face-attribute inherited-face attribute)))))
    ;; (message "face: %S attribute: %S display-attr: %S, val: %S" face attribute display-attr val) ;; for debugging
    (or val 'unspecified)))

(advice-add 'face-attribute :override #'my-face-attribute)

;; Debugging
(defmacro print-args-and-ret (fun)
  "Prepare FUN for printing args and return value."
  `(advice-add (quote ,fun) :around
           (lambda (oldfun &rest args)
         (let ((ret (apply oldfun args)))
           (message ,(concat "Calling " (symbol-name fun) " with args %S returns %S.") args ret)
           ret))
           '((name "print-args-and-ret"))))

; (print-args-and-ret htmlize-faces-in-buffer)
; (print-args-and-ret htmlize-get-override-fstruct)
; (print-args-and-ret htmlize-face-to-fstruct)
; (print-args-and-ret htmlize-attrlist-to-fstruct)
; (print-args-and-ret face-foreground)
; (print-args-and-ret face-background)
; (print-args-and-ret face-attribute)
#+end_src

*** Fix non-determinism

There are some things that Org mode does that annoyingly break determinism. Here we take care to set things right so that we can have reprducible, stable HTML output.

**** Do not insert current time as HTML comment

Org mode also injects an HTML comment (not visible to the user) to record the time that the HTML was generated. We disable this because it breaks deterministic output. See [[https://emacs.stackexchange.com/questions/50117/how-to-disable-commented-date-in-org-mode-html-export][this link]] for more info.

#+header: :noweb-ref __NREF__codex_dot_el-fix-nondeterminism
#+begin_src emacs-lisp
(setq org-export-time-stamp-file nil)
#+end_src

**** Do not insert current Org mode version

By default Org mode appends visible metadata at the bottom of the HTML document, including the Org version used to generate the document. We suppress this information.

#+header: :noweb-ref __NREF__codex_dot_el-fix-nondeterminism
#+begin_src emacs-lisp
(setq org-html-postamble nil)
#+end_src

**** Do not use random numbers for the HTML "id" attribute

Stop randomized ids from being generated every time. Instead count from 0 and work our way up.

See https://www.reddit.com/r/orgmode/comments/aagmfh/comment/hk6upbf.

#+header: :noweb-ref __NREF__codex_dot_el-fix-nondeterminism
#+begin_src emacs-lisp
(defun org-export-deterministic-reference (references)
  (let ((new (length references)))
     (while (rassq new references) (setq new (+ new 1)))
     new))
(advice-add #'org-export-new-reference :override #'org-export-deterministic-reference)
#+end_src

*** Misc settings

Disable backup files for =codex.el= (that look like =codex.el~=) when we invoke Emacs from the [[Makefile]].

#+name: __NREF__codex_dot_el-misc
#+begin_src emacs-lisp
(setq make-backup-files nil)
__NREF__set_html5
#+end_src

**** Use HTML5 export, not XML (to un-break MathJax)

By default on Org 9.6, MathJax settings (JavaScript snippet) gets wrapped in a CDATA tag, and we run into the same problem described on this email that has gone unanswered: https://www.mail-archive.com/emacs-orgmode@gnu.org/msg140821.html. It appears that this is because the document is exported as XML, not HTMl. Setting the document type to =html5=, as below, appears to make the CDATA tag magically disappear.

#+name: __NREF__set_html5
#+begin_src emacs-lisp
(setq org-html-doctype "html5")
#+end_src

**** TODO move this bit into a snippet that's autoloaded upon opening up this org file (and any other org file that we use)

#+name: set_org_link_behavior
#+begin_src emacs-lisp
(setq org-id-link-to-org-use-id 't)
#+end_src

The following bit is needed so that Org is able to resolve ID-style links of the form =[[id:...][...]=. We just list all of our Org files so that they can be parsed for link IDs. We could generate the list of Org files dynamically, but because there are so few of these, we just do it manually here.

NOTE: Actually, this doesn't work because we need to inject "ID" properties everywhere (and unfortunately these gets exported, creating a mess) and also the links themselves are broken because of the way we include these files into the main file.

#+name: org_reset_link_ids
#+begin_src emacs-lisp
(let ((files '("build-literate.org"
               "README.org")))
  (org-id-update-id-locations files))
#+end_src

*** Imports

#+name: __NREF__codex_dot_el-imports
#+begin_src emacs-lisp
;; Built-in packages (distributed with Emacs).
(require 'tex-mode)
(require 'elisp-mode)

;; Third-party packages (checked in as Git submodules)
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/s.el"))
(require 's)
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/compat.el"))
(require 'compat)
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/dash.el"))
(require 'dash)
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/dr-qubit.org"))
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/f.el"))
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/parsebib"))
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/citeproc-el"))
(require 'citeproc)
(require 'oc-csl)
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/emacs-htmlize"))
(require 'htmlize)
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/magit/lisp"))
(require 'magit-section)
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/nix-mode"))
(require 'nix-mode)
#+end_src

*** Performance optimizations

This "optimization" is inspired by [[https://www.reddit.com/r/emacs/comments/mmdeei/comment/gtvryvy]]. There, the idea was to ignore hooks associated with major modes for the source code blocks, Because they use =org-publish= and we don't, we can't use the same code but we can still use the same idea. In particular, =org-html-export-to-html= calls =org-html-fontify-code= to perform syntax highlighting of source code blocks.

During ad-hoc tests, this shaves off a few seconds. This was determined by comparing the regular =weave= target versus the =weave-nocolor= target.

#+name: __NREF__codex_dot_el-performance-optimization
#+begin_src emacs-lisp
; Set garbage-collection threshold to 16 GiB.
(setq gc-cons-threshold #x400000000)

(defun codex-disable-syntax-highlighting (_orig-func &rest args)
  (apply 'codex-org-html-fontify-code args))
(defun codex-org-html-fontify-code (code lang) (org-html-encode-plain-text code))

__NREF__codex_dot_el-profiling
#+end_src

**** Profiling

#+name: __NREF__codex_dot_el-profiling
#+begin_src emacs-lisp
(defun codex-publish-profile ()
  (interactive)
  (profiler-start 'cpu)
  (codex-publish)
  (profiler-stop)
  (profiler-report)
  (profiler-report-write-profile "emacs-profile-weave.txt") t)

(defun codex-tangle-profile ()
  (interactive)
  (profiler-start 'cpu)
  (org-babel-tangle)
  (profiler-stop)
  (profiler-report)
  (profiler-report-write-profile "emacs-profile-tangle.txt") t)
#+end_src

** Additional (hand-tweaked) CSS

We add some additional CSS tweaks on top of the default "ReadTheOrg" (FIXME: add link) theme that we use.

#+name: style.css
#+caption: =style.css=
#+begin_src css :tangle style.css
a {
    color: #0000ff;
}

body, p, li, h1, h2, h3, h4, h5, h6, legend {
    font-family: "Source Serif Pro, serif";
}

p, li {
    line-height: 1.2em;
}

p, ol, ul {
    margin-bottom: 0.5em;
}

li {
    margin-bottom: 0;
}

table {
    margin: 0 auto;
}

/* Center all images. */
img {
    display: block;
    margin: 0 auto;
}

/* Increase text size for smaller sections. */
h5 {
    margin-top: 1em;
    margin-bottom: 1em;
    font-size: 12pt;
}
h6 {
    margin-top: 1em;
    margin-bottom: 1em;
    font-size: 12pt;
}
h7 {
    font-weight: bold;
    font-size: 12pt;
}
.outline-7 {
    margin-top: 1em;
}

code {
    background: #eee;
    padding-left: 0.5em;
    padding-right: 0.5em;
    white-space: nowrap;
}

thead {
    background: #eee;
}

pre {
    border-style: solid;
    border-width: 1px;
    border-color: #999;
    border-radius: 5px;
}

__NREF__css-source-code-block-body
__NREF__css-source-code-block-captions
__NREF__css-source-code-block-child-link-from-parent
#+end_src

*** Source code block body

#+name: __NREF__css-source-code-block-body
#+begin_src css
.org-src-container {
    margin-top: 1em;
    margin-bottom: 1em;
    border-style: solid;
    border-width: 1px;
    border-color: #999;
    border-radius: 5px;
}

.org-src-container pre {
    margin: 0;
    font-family: "monospace";
    border-width: 0;
    border-radius: 5px;
}

.org-src-container .codex-pre-with-caption {
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
}

/* Source code block body. */
.org-src-container pre.src {
    background-color: #eee;
}

#+end_src

*** Source code block captions

#+name: __NREF__css-source-code-block-captions
#+begin_src css
.codex-caption {
    font-family: "monospace";
    text-align: right;
    background-color: #e8fffd;
    border-bottom-left-radius: 5px;
    border-bottom-right-radius: 5px;
}

.codex-caption-source-code-block-name {
    color: #444444;
    font-weight: bold;
    margin-right: 5px;
}

.codex-caption-parent-link {
    margin-right: 5px;
}

.codex-caption-listing-number {
    margin-right: 5px;
}
#+end_src

*** Links to child source block from parent

#+name: __NREF__css-source-code-block-child-link-from-parent
#+begin_src css
.codex-child-link-from-parent {
    padding-left: 5px;
    padding-right: 5px;
    background-color: #389ffd;
    border-style: solid;
    border-width: 1px;
    border-color: #00f;
    border-radius: 3px;
}
.codex-child-link-from-parent a {
    color: #ffffff;
    font-weight: bold;
}
#+end_src

** Diagrams

The code used to generate the diagrams used in this doc is [[file:image.html][here]]. We don't discuss that code in this doc because it would make this doc even more verbose.

** Ignore woven HTML from =git diff=

Typically we only need to look at the rendered HTML output in a web browser as the raw HTML diff output is extremely difficult to parse as a human. So by default we ask Git to exclude it from =git diff= by treating them as binary data.

#+caption: =.gitattributes=
#+begin_src gitattributes :tangle .gitattributes :eval no
,* -diff
,**/*.org diff
,**/.gitattributes diff
,**/.gitmodules diff
,**/.gitignore diff
#+end_src

In order to still show the HTML textual diff, we can run =git diff --text=.

*** =git add -p=

Note that the above setting to treat HTML files as binary data prevents them from being considered for =git add -p=. In order to add them, use =git add -u= instead.

* Tangling (generating the source code)

Tangling is simply the act of collecting the =#+begin_src ... #+end_src= blocks and arranging them into the various target (source code) files. Every source code block is given a unique name.

We simply tangle all major =*.org= files in the toplevel Makefile.

#+name: __NREF__Makefile-tangle
#+begin_src makefile
do-tangle: tangle-sources
.PHONY: do-tangle

# Currently we don't have any optimizations for tangling, but we still set CODEX_LP_QUICK=1 anyway to align with what we do for weave-quick.
tangle:
	CODEX_LP_QUICK=1 make -C $(PROJ_ROOT) -j$(PROCS) do-tangle
.PHONY: tangle

build-literate-org:
	# Generate the toplevel Makefile (this file) and image/Makefile (overwriting
	# them if necessary). In a way this bootstraps the whole
	# literate-programming pipeline. Note that these files are different than
	# the ones used to compile the tangled source code.
	$(call run_emacs,(org-babel-tangle),build-literate.org)

# Generate source code.
tangle-sources: README-org

README-org: build-literate-org
	$(call run_emacs,(org-babel-tangle),README.org)
	$(call run_emacs,(org-babel-tangle),problem/parity/README.org)

.PHONY: build-literate-org tangle-sources
#+end_src

* Glossary

- <<monoblock>> *monoblock*: an Org mode source code block with a =#+name: ...= field. This block is an independent block and there are no other blocks with the same name.
- *Noweb*: A literate programming tool from 1989 that still works and from which [[Org mode][Org mode]] borrows heavily using [[noweb-ref][Noweb-style references]]. See [[https://en.wikipedia.org/wiki/Noweb][Wikipedia]].
- <<noweb-ref>> *noweb-ref*: aka "Noweb-style reference". A Noweb-style reference is just a name (string) that refers to a monoblock or polyblock. See [[https://orgmode.org/manual/Noweb-Reference-Syntax.html][the Org manual]].
- <<Org mode>> *Org mode*: An Emacs major mode for =*.org= files, where "major mode" means that it provides things like syntax highlighting and keyboard shortcuts for =*.org= text files if you are using Emacs. For Codex, the important thing is that we use Org mode as a literate programming tool. See [[https://orgmode.org/][Org mode]].
- <<polyblock>> *polyblock*: an Org mode source code block without a =#+name: ...= field, but which has a =#+header: :noweb-ref ...= field. Other blocks with the same noweb-ref name are concatenated together when they are tangled. Polyblocks are used in cases where we would like to break up a single block into much smaller pieces for explanatory purposes. In all other cases, monoblocks are preferable, unless the source code block is not to be tangled and is only for explanatory purposes in the woven output.
- *source code block*: An Org mode facility that allows you to enclose a multiline piece of text with =#+begin_src ...= and =#+end_src= lines.
