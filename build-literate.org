#+title: Literate Programming Build System
#+PROPERTY: header-args :noweb no-export

We use [[https://github.com/listx/lilac][Lilac]] for literate programming.

* Weaving (generating the docs)

#+name: Makefile
#+caption: Makefile
#+begin_src makefile :tangle Makefile :eval no
PROJ_ROOT := $(shell git rev-parse --show-toplevel)
LILAC_ROOT := $(PROJ_ROOT)/deps/elisp/lilac
PROCS := $(shell nproc)
define run_emacs
	LILAC_ROOT=$(LILAC_ROOT) emacs $(2) --quick --batch --kill \
		--load $(LILAC_ROOT)/lilac.el \
		--load $(PROJ_ROOT)/codex.el \
		--eval="$(1)"
endef
src = $(shell find problem/ -type f -name '*.org')
src_appendix = $(shell find appendix/ -type f -name '*.org')
woven_html = $(patsubst problem/%.org, problem/%.html, $(src)) \
	$(patsubst appendix/%.org, appendix/%.html, $(src_appendix))
# problem/foo problem/bar ...
problem_dirs = $(shell find problem -maxdepth 1 -type d | sort | tail -n+2)
appendix_dirs = $(shell find appendix -maxdepth 1 -type d | sort | tail -n+2)
# foo bar ...
problem_dirs_without_prefix = $(subst problem/,,$(problem_dirs))
appendix_dirs_without_prefix = $(subst appendix/,,$(appendix_dirs))

define weave_org

$(1): $(2) build-literate.org
	@echo weaving $(2)
	$(call run_emacs,(lilac-publish),$(2))
	sed -i 's/<style>.csl-left-margin{float: left; padding-right: 0em/\
<style>.csl-left-margin{float: left; padding-right: 1em/' $(1)
	sed -i 's/.csl-right-inline{margin: 0 0 0 1em;}<\/style>/\
.csl-right-inline{margin: 0 0 0 2em;}<\/style>/' $(1)
	sed -i 's|<h2>Table of Contents</h2>||' $(1)

endef

all: check weave
.PHONY: all

__NREF__Makefile-tangle

weave: build-html

build-html: README.html $(woven_html)
.PHONY: build-html
.PHONY: appendix/mathematics/twos-complement.html

README.html: build-literate.org README.org citations.bib
	$(call run_emacs,(lilac-gen-css-and-exit),README.org)
	$(call run_emacs,(lilac-publish),README.org)
	sed -i 's/<style>.csl-left-margin{float: left; padding-right: 0em/'\
	'<style>.csl-left-margin{float: left; padding-right: 1em/' README.html
	sed -i 's/.csl-right-inline{margin: 0 0 0 1em;}<\/style>/'\
	'.csl-right-inline{margin: 0 0 0 2em;}<\/style>/' README.html
	sed -i 's|<h2>Table of Contents</h2>||' README.html

$(foreach d,$(appendix_dirs_without_prefix),\
	$(eval $(call weave_org,\
	appendix/$(d)/README.html,\
	appendix/$(d)/README.org)))

$(foreach d,$(problem_dirs_without_prefix),\
	$(eval $(call weave_org,\
	problem/$(d)/README.html,\
	problem/$(d)/README.org)))

check: lint test
.PHONY: check

test: tangle
	python -m unittest discover -s problem
	touch test

lint: mypy ruff
.PHONY: lint

mypy: tangle
	mypy problem
.PHONY: mypy

ruff: tangle
	ruff problem
.PHONY: ruff

# Enter development environment.
shell:
	nix-shell --pure

__NREF__Makefile-update-deps
#+end_src

** Use =lilac.theme= file

** Ignore woven HTML from =git diff=

Typically we only need to look at the rendered HTML output in a web browser as
the raw HTML diff output is extremely difficult to parse as a human. So by
default we ask Git to exclude it from =git diff= by treating them as binary
data.

#+name: .gitattributes
#+caption: .gitattributes
#+begin_src gitattributes :tangle .gitattributes :eval no
,* -diff
,**/*.org diff
,**/.gitattributes diff
,**/.gitmodules diff
,**/.gitignore diff
#+end_src

In order to still show the HTML textual diff, we can run =git diff --text=.

*** =git add -p=

Note that the above setting to treat HTML files as binary data prevents them
from being considered for =git add -p=. In order to add them, use =git add -u=
instead.

** gitignore

#+name: .gitignore
#+caption: .gitignore
#+begin_src gitignore :tangle .gitignore :eval no
,**/__pycache__
,**/*.auctex-auto
,**/*.hypothesis
tangle
test
update-deps
weave
#+end_src

* Tangling (generating the source code)

Tangling is simply the act of collecting the =#+begin_src ... #+end_src= blocks
and arranging them into the various target (source code) files. Every source
code block is given a unique name.

We simply tangle all major =*.org= files in the toplevel Makefile.

#+name: __NREF__Makefile-tangle
#+begin_src makefile
# Currently we don't have any optimizations for tangling, but we still set
# CODEX_LP_QUICK=1 anyway to align with what we do for weave-quick.
$(all_tangled_sources) tangle &: $(src)
	@echo tangling in parallel
	CODEX_LP_QUICK=1 make -C $(PROJ_ROOT) -j$(PROCS) $(all_tangled_sources)
	touch tangle

build_literate_org_output = .gitattributes .gitignore Makefile shell.nix
all_tangled_sources = citations.bib $(build_literate_org_output)\
	appendix/python_tricks/__init__.py \
	appendix/python_tricks/test_python_tricks.py \
	$(foreach p,$(problem_dirs_without_prefix),\
		problem/$(p)/__init__.py problem/$(p)/test_$(p).py)

$(build_literate_org_output) &: build-literate.org
	$(call run_emacs,(org-babel-tangle),build-literate.org)

citations.bib: README.org
	$(call run_emacs,(org-babel-tangle),README.org)

appendix/python_tricks/test_python_tricks.py: appendix/python_tricks/README.org
	$(call run_emacs,(org-babel-tangle),appendix/python_tricks/README.org)

define tangle_tests

$(1) $(2) &: $(3)
	@echo tangling $(3)
	$(call run_emacs,(org-babel-tangle),$(3))

endef

# See https://stackoverflow.com/a/9694782/437583.
$(foreach p,$(problem_dirs_without_prefix),\
	$(eval $(call tangle_tests,\
	problem/$(p)/__init__.py,problem/$(p)/test_$(p).py,\
	problem/$(p)/README.org)))
#+end_src

* Development environment (Nix shell)

This is taken from https://github.com/tweag/haskell-stack-nix-example/blob/b9383e35416a2b0e21fbc97ed079538f9f395b6a/shell.nix#L1.

This is the main development shell and brings in all of our dependencies to
build all of our code. It's great for development and testing things out (such
as running "make" to re-run any Python tests that have been updated when adding
new problems).

#+name: shell.nix
#+caption: shell.nix
#+begin_src nix :tangle shell.nix :eval no
let
  # Nixpkgs snapshot.
  sources = import ./package/nix/sources.nix;
  # The final "pkgs" attribute with all the bells and whistles of our overlays.
  pkgs = import sources.nixpkgs {};
in

# This is our development shell.
pkgs.mkShell ({
  buildInputs = [
    # Tangling and weaving for Literate Programming.
    pkgs.emacs

    # Misc
    pkgs.git
    pkgs.less

    # Python testing and linting.
    pkgs.python39Packages.hypothesis
    pkgs.python39Packages.mypy
    pkgs.ruff
  ];
})
#+end_src

** Update Nix dependencies

This is based on Lilac's own code for updating Nix dependencies with [[https://github.com/nmattia/niv][=niv=]].

#+name: __NREF__Makefile-update-deps
#+begin_src makefile
nixpkgs_stable_channel := nixos-23.05
update-deps: package/nix/sources.json package/nix/sources.nix
	cd package && niv update nixpkgs --branch $(nixpkgs_stable_channel)
	cd package && niv update
	touch update-deps
#+end_src

* Elisp

#+name: codex.el
#+caption: codex.el
#+begin_src emacs-lisp :tangle codex.el :eval no
; See https://stackoverflow.com/a/27285582/437583.
(defun codex-test-file-name ()
  (concat "test_" (file-name-nondirectory
                   (directory-file-name
                    (file-name-directory (buffer-file-name))))  ".py"))

(setq org-cite-csl-styles-dir
      (concat (getenv "LILAC_ROOT") "/deps/styles/"))
#+end_src
