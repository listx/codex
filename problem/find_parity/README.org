#+title: Find parity of words
#+PROPERTY: header-args :noweb no-export
#+OPTIONS: H:5

* Introduction

/Parity/ of a word is defined as =1= if there are an odd number of 1-bits in the word, and =0= otherwise.

Examples:

|       Word | Number of 1-bits set | Parity |
|------------+----------------------+--------|
|       1011 | 3 (odd)              |      1 |
| 1000010000 | 2 (even)             |      0 |
|         11 | 2 (even)             |      0 |
|      11111 | 5 (odd)              |      1 |

* Problem statement

Design an algorithm for computing the parity of a large number of 64-bit words.

* Brute force

#+name: brute_force
#+begin_src python
def parity(word):
  parity_bit = 0
  while word:
    parity_bit ^= word & 1
    word >>= 1
  return parity_bit
#+end_src

This approach just computes the parity of a single word by examining every bit in the word. It also uses bitwise XOR to only store 1 or 0 (instead of actually storing the actual number of bits). Because of the way XOR works, when the number of bits is odd (starting with the very first 1-bit), the parity is set to 1. Then if another 1-bit comes along (even) it is XOR-ed against the previously-calculated parity bit 1 to become 0. Then if another bit (odd) comes along, the 0 is XOR-ed against it to become 1 again, and so forth.

The space complexity is O(1) because we only store 0 or 1 for the parity bit. The time complexity is O(n) where n is the word size.

* Tests

#+begin_src python :session test :tangle test_parity.py
import unittest

<<brute_force>>

class TestParity(unittest.TestCase):
  def test_bf(self):
    self.assertEqual(parity(0b0), 0)
    self.assertEqual(parity(0b1), 1)
    self.assertEqual(parity(0b1011), 1)
    self.assertEqual(parity(0b1000010000), 0)
    self.assertEqual(parity(0b11), 0)
    self.assertEqual(parity(0b11111), 1)

if __name__ == "__main__":
  unittest.main(exit=False)
#+end_src

** Boilerplate

#+begin_src python :tangle __init__.py
#+end_src
