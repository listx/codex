<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Buy and sell stock twice</title>
<meta name="author" content="Linus Arver" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="syntax-highlighting.css"/>
<link rel="stylesheet" type="text/css" href="lilac.css" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro&family=Source+Code+Pro">
<script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
<script src="lilac.js"></script>
<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Buy and sell stock twice</h1>
<div id="table-of-contents" role="doc-toc">

<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#h-Problem-statement">1. Problem statement</a>
<ul>
<li><a href="#h-Inputs-and-outputs">1.1. Inputs and outputs</a></li>
<li><a href="#h-Housekeeping">1.2. Housekeeping</a></li>
</ul>
</li>
<li><a href="#h-Insights">2. Insights</a></li>
<li><a href="#h-Solutions">3. Solutions</a>
<ul>
<li><a href="#h-Brute-force">3.1. Brute force</a>
<ul>
<li><a href="#h-Complexity">3.1.1. Complexity</a></li>
<li><a href="#h-Tweaks">3.1.2. Tweaks</a></li>
</ul>
</li>
<li><a href="#h-Two-pass-algorithm">3.2. Two-pass algorithm</a>
<ul>
<li><a href="#h-Complexity-1">3.2.1. Complexity</a></li>
</ul>
</li>
<li><a href="#h-Single-pass-algorithm">3.3. Single-pass algorithm</a>
<ul>
<li><a href="#h-Complexity-2">3.3.1. Complexity</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h-Tests">4. Tests</a></li>
<li><a href="#h-References">5. References</a></li>
</ul>
</div>
</div>

<div id="outline-container-h-Problem-statement" class="outline-2">
<h2 id="h-Problem-statement"><span class="section-number-2">1.</span> Problem statement</h2>
<div class="outline-text-2" id="text-h-Problem-statement">
<p>
This is the same problem as in <a href="file:///Users/l/prog/codex/problem/buy_sell_stock_once/README.html">"Buy and sell stock once"</a> but with the difference that we can buy and sell again within the same range (<a href="#citeproc_bib_item_1">Aziz et al., 2018, p. 53</a>). This means that you can buy/sell once, or twice, in order to maximize the profit.
</p>
</div>

<div id="outline-container-h-Inputs-and-outputs" class="outline-3">
<h3 id="h-Inputs-and-outputs"><span class="section-number-3">1.1.</span> Inputs and outputs</h3>
<div class="outline-text-3" id="text-h-Inputs-and-outputs">
<ul class="org-ul">
<li>Input
<ul class="org-ul">
<li>list of stock prices (positive numbers)</li>
</ul></li>
<li>Output
<ul class="org-ul">
<li>day to buy the stock</li>
<li>day to sell the stock</li>
<li>day to buy the stock</li>
<li>day to sell the stock</li>
<li>the realized profit margin</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-h-Housekeeping" class="outline-3">
<h3 id="h-Housekeeping"><span class="section-number-3">1.2.</span> Housekeeping</h3>
<div class="outline-text-3" id="text-h-Housekeeping">
<p>
There are a lot of moving parts to keep track of. Let's use a data type to keep things orderly.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Tests">buy_sell_twice</a></span>(1/6) <span class="lilac-caption-link-symbol"><a href="#__NREF__buy_sell_twice-1">&#x1f517;</a></span></div><pre class="src src-python" id="__NREF__buy_sell_twice-1"><span class="org-keyword">from</span> typing <span class="org-keyword">import</span> Optional

<span class="org-keyword">import</span> collections
<span class="org-variable-name">TXN</span> = collections.namedtuple(<span class="org-string">'TXN'</span>, (<span class="org-string">'buy_date'</span>, <span class="org-string">'sell_date'</span>, <span class="org-string">'profit'</span>))
</pre></div></div>
</div>
</div>
</div>

<div id="outline-container-h-Insights" class="outline-2">
<h2 id="h-Insights"><span class="section-number-2">2.</span> Insights</h2>
<div class="outline-text-2" id="text-h-Insights">
<p>
We can divide up the prices into two sublists. The first sublist is a buy/sell window, and the second sublist is another separate buy/sell window.
</p>

<pre class="example" id="org0000004">
prices = [1,   2,   3,   1,   2,   3]

split1 = [1,   2]  [3,   1,   2,   3]
split2 = [1,   2,   3]   [1,  2,   3]
split3 = [1,   2,   3,   1]  [2,   3]
</pre>

<p>
This way, we can consider the maximum possible buy/sell profit margin (same algorithm as in <a href="file:///Users/l/prog/codex/problem/buy_sell_stock_once/README.html">"Buy and sell stock once"</a>) of each sublist. Then we can work with these 2 buy/sell profits and just sum them up as we consider each split.
</p>

<p>
The downside with the above approach is that we we're not reusing the information gleaned from the earlier splits in the later splits. So there's some level of duplicate work.
</p>

<p>
Instead we can do a 2-pass algorithm. Here we consider two cases: (1) selling on the current day (with the minimum (buy point) looking into the past), and (2) buying on the current day (with the maximum (sell point) looking into the future). The final trick is to make sure that the days considered in both passes are on different days (to simulate buying and selling twice).
</p>
</div>
</div>

<div id="outline-container-h-Solutions" class="outline-2">
<h2 id="h-Solutions"><span class="section-number-2">3.</span> Solutions</h2>
<div class="outline-text-2" id="text-h-Solutions">
</div>

<div id="outline-container-h-Brute-force" class="outline-3">
<h3 id="h-Brute-force"><span class="section-number-3">3.1.</span> Brute force</h3>
<div class="outline-text-3" id="text-h-Brute-force">
<p>
First get the optimum buy/sell dates if we are only buying and selling just once.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Tests">buy_sell_twice</a></span>(2/6) <span class="lilac-caption-link-symbol"><a href="#__NREF__buy_sell_twice-2">&#x1f517;</a></span></div><pre class="src src-python" id="__NREF__buy_sell_twice-2"><span class="org-keyword">def</span> <span class="org-function-name">brute_force</span>(prices: <span class="org-builtin">list</span>[<span class="org-builtin">int</span>]) -&gt; <span class="org-variable-name">Optional</span>[TXN]:
  <span class="org-keyword">if</span> <span class="org-keyword">not</span> prices:
    <span class="org-keyword">return</span> <span class="org-constant">None</span>

  max_profit_so_far = 0
  <span class="org-keyword">for</span> buy_date, price_buy <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(prices):
    <span class="org-keyword">for</span> sell_date <span class="org-keyword">in</span> <span class="org-builtin">range</span>(buy_date + 1, <span class="org-builtin">len</span>(prices)):
      <span class="org-variable-name">profit</span> = prices[sell_date] - price_buy
      <span class="org-keyword">if</span> profit &gt; <span class="org-variable-name">max_profit_so_far</span>:
        max_profit_so_far = profit
        <span class="org-variable-name">transaction_dates</span> = TXN(buy_date, sell_date, profit)

  <span class="org-keyword">if</span> max_profit_so_far:
    <span class="org-keyword">return</span> transaction_dates

  <span class="org-comment-delimiter"># </span><span class="org-comment">If no profitable trade found, return None.</span>
  <span class="org-keyword">return</span> <span class="org-constant">None</span>
</pre></div></div><p>
Now split up the given list into 2 sublists, where each sublist must have length 2 or greater. The length must be at least 2, because this is the minimum length for buying and selling. Now run <code>brute_force</code> against each of these sublists. If the two buy/sell transactions' combined profit is greater than the single transaction's profit, we take note of it.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Tests">buy_sell_twice</a></span>(3/6) <span class="lilac-caption-link-symbol"><a href="#__NREF__buy_sell_twice-3">&#x1f517;</a></span></div><pre class="src src-python" id="__NREF__buy_sell_twice-3"><span class="org-keyword">def</span> <span class="org-function-name">brute_force_sublists</span>(prices: <span class="org-builtin">list</span>[<span class="org-builtin">int</span>]
  ) -&gt; Optional[<span class="org-builtin">tuple</span>[TXN, TXN]]:

  <span class="org-comment-delimiter"># </span><span class="org-comment">There are 2 sublists and each one must have at least 2 items.</span>
  <span class="org-keyword">if</span> <span class="org-builtin">len</span>(prices) &lt; 4:
    <span class="org-keyword">return</span> <span class="org-constant">None</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Divide up prices into sublists.</span>
  <span class="org-variable-name">sublists</span> = [(prices[0:i], prices[i:])
   <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(0, <span class="org-builtin">len</span>(prices))
   <span class="org-keyword">if</span> i &gt; 1 <span class="org-keyword">and</span> <span class="org-builtin">len</span>(prices) - i &gt; 1]

  <span class="org-variable-name">txn_dates</span> = <span class="org-constant">None</span>
  <span class="org-variable-name">max_sell_twice</span> = 0
  <span class="org-keyword">for</span> list1, list2 <span class="org-keyword">in</span> <span class="org-variable-name">sublists</span>:
    txn1 = brute_force(list1)
    <span class="org-variable-name">txn2</span> = brute_force(list2)
    <span class="org-keyword">if</span> txn1 <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span> <span class="org-keyword">and</span> txn2 <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
      <span class="org-keyword">if</span> txn1.profit + txn2.profit &gt; <span class="org-variable-name">max_sell_twice</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">The indices (dates) for txn2 are wrong because list2 will start at its</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">own index 0. So we need to give the dates an offset.</span>
        txn2 = txn2._replace(buy_date = txn2.buy_date + <span class="org-builtin">len</span>(list1))
        txn2 = txn2._replace(sell_date = txn2.sell_date + <span class="org-builtin">len</span>(list1))

        txn_dates = (txn1, txn2)
        max_sell_twice = <span class="org-builtin">max</span>(txn1.profit + txn2.profit,
                             max_sell_twice)

  <span class="org-keyword">if</span> max_sell_twice:
    <span class="org-keyword">return</span> txn_dates

  <span class="org-keyword">return</span> <span class="org-constant">None</span>
</pre></div></div><p>
Now that we know how to calculate the max profit for a single transaction as well as two transactions, we just have to compare them and see which one has a greater profit.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Tests">buy_sell_twice</a></span>(4/6) <span class="lilac-caption-link-symbol"><a href="#__NREF__buy_sell_twice-4">&#x1f517;</a></span></div><pre class="src src-python" id="__NREF__buy_sell_twice-4"><span class="org-keyword">def</span> <span class="org-function-name">brute_force_maybe_sell_twice</span>(prices: <span class="org-builtin">list</span>[<span class="org-builtin">int</span>]
  ) -&gt; Optional[<span class="org-builtin">tuple</span>[Optional[TXN], Optional[TXN]]]:

  <span class="org-variable-name">txn</span> = brute_force(prices)
  <span class="org-variable-name">txn_pair</span> = brute_force_sublists(prices)

  <span class="org-comment-delimiter"># </span><span class="org-comment">If there's no way to make a profit with a single sale, give up.</span>
  <span class="org-keyword">if</span> txn <span class="org-keyword">is</span> <span class="org-constant">None</span>:
    <span class="org-keyword">return</span> <span class="org-constant">None</span>

  <span class="org-keyword">if</span> txn_pair <span class="org-keyword">is</span> <span class="org-constant">None</span>:
    <span class="org-keyword">return</span> txn, <span class="org-constant">None</span>

  max_sell_twice = txn_pair[0].profit + txn_pair[1].profit

  <span class="org-keyword">if</span> max_sell_twice &gt; txn.profit:
    <span class="org-keyword">return</span> txn_pair

  <span class="org-comment-delimiter"># </span><span class="org-comment">If the max_sell_twice profit wasn't bigger, then the best we got is the one</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">from the one sale in txn.</span>
  <span class="org-keyword">return</span> txn, <span class="org-constant">None</span>
</pre></div></div>
</div>

<div id="outline-container-h-Complexity" class="outline-4">
<h4 id="h-Complexity"><span class="section-number-4">3.1.1.</span> Complexity</h4>
<div class="outline-text-4" id="text-h-Complexity">
<ul class="org-ul">
<li>Time: \(O(n^4)\)</li>
<li>Space: \(O(1)\)</li>
</ul>
</div>
</div>

<div id="outline-container-h-Tweaks" class="outline-4">
<h4 id="h-Tweaks"><span class="section-number-4">3.1.2.</span> Tweaks</h4>
<div class="outline-text-4" id="text-h-Tweaks">
<p>
If we use the <code>optimal()</code> algorithm in <a href="file:///Users/l/prog/codex/problem/buy_sell_stock_once/README.html">"Buy and sell stock once"</a> and use that to replace the call to <code>brute_force()</code>, we can get the time complexity down to \(O(n^2)\), because for each sublist, we will call <code>optimal()</code> (which has \(O(n)\) time complexity).
</p>
</div>
</div>
</div>

<div id="outline-container-h-Two-pass-algorithm" class="outline-3">
<h3 id="h-Two-pass-algorithm"><span class="section-number-3">3.2.</span> Two-pass algorithm</h3>
<div class="outline-text-3" id="text-h-Two-pass-algorithm">
<p>
The first pass is basically the same as <code>optimal()</code> from <a href="file:///Users/l/prog/codex/problem/buy_sell_stock_once/README.html">"Buy and sell stock once"</a>, but applied twice &#x2013; once "forward" and again "backward". In the first pass, we record the max possible profit if we're selling on that day. This pass is basically the same as the optimum solution in <a href="file:///Users/l/prog/codex/problem/buy_sell_stock_once/README.html">"Buy and sell stock once"</a>. The algorithm there iterates through each price, keeps a running <i>minimum</i> price seen (this assumes buying at that time), and records a profit or loss by selling on the day it is looking at.
</p>

<p>
Then we can do a second pass by iterating through each day in reverse, getting the max profit if we we're <i>buying</i> on that day &#x2014; this is the inverse of the first pass because we track the running <i>maximum price</i> (thereby assuming that we <i>sell</i> on that day). The current day we're looking at is the day of the second purchase. During this second pass we can use the information from the first pass to determine the max possible profit for buying and selling twice.
</p>

<p>
Essentially these two passes, on their own, can get the same answer for the scenario of buying and selling once. The first one asks "assuming that we bought already and <i>must sell</i> today, how much money can I make?" while the second one asks "assuming that we must sell sometime in the future and <i>must buy</i> today, how much money will I make?". They are two sides of the same coin. The key property of the second question though, is that we can ask it while iterating backwards in time, such that we only have to iterate backwards <i>once</i>, just like how we can iterate forwards <i>once</i> with the first algorithm. Using these two complementary styles minimizes the number of traversals because we can burn the candle at both ends, so to speak.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Tests">buy_sell_twice</a></span>(5/6) <span class="lilac-caption-link-symbol"><a href="#__NREF__buy_sell_twice-5">&#x1f517;</a></span></div><pre class="src src-python" id="__NREF__buy_sell_twice-5"><span class="org-keyword">def</span> <span class="org-function-name">two_pass_maybe_sell_twice</span>(prices: <span class="org-builtin">list</span>[<span class="org-builtin">int</span>]
  ) -&gt; Optional[<span class="org-builtin">tuple</span>[Optional[TXN], Optional[TXN]]]:
  <span class="org-keyword">if</span> <span class="org-builtin">len</span>(prices) &lt; 2:
    <span class="org-keyword">return</span> <span class="org-constant">None</span>

  <span class="org-variable-name">min_price_so_far</span> = <span class="org-builtin">float</span>(<span class="org-string">'inf'</span>)
  <span class="org-variable-name">max_profit_sell_once</span> = 0
  <span class="org-variable-name">txn1</span> = <span class="org-constant">None</span>
  <span class="org-variable-name">txn2</span> = <span class="org-constant">None</span>
  <span class="org-variable-name">profit_txn1</span> = [TXN(-1, -1, -1)] * <span class="org-builtin">len</span>(prices)

  <span class="org-keyword">for</span> date, price <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(prices):
    <span class="org-keyword">if</span> price &lt; <span class="org-variable-name">min_price_so_far</span>:
      buy_date = date
      <span class="org-variable-name">min_price_so_far</span> = <span class="org-builtin">min</span>(price, min_price_so_far)

    <span class="org-variable-name">max_profit_if_sell_now</span> = price - min_price_so_far

    <span class="org-keyword">if</span> max_profit_if_sell_now &gt; <span class="org-variable-name">max_profit_sell_once</span>:
      max_profit_sell_once = <span class="org-builtin">max</span>(<span class="org-builtin">int</span>(max_profit_if_sell_now), max_profit_sell_once)
      <span class="org-variable-name">txn1</span> = TXN(buy_date, date, max_profit_sell_once)

    <span class="org-keyword">if</span> txn1 <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
      profit_txn1[<span class="org-variable-name">date</span>] = txn1

  <span class="org-comment-delimiter"># </span><span class="org-comment">Our current understanding of the max possible profit is by looking at one</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">buy and one sell.</span>
  <span class="org-variable-name">max_profit</span> = max_profit_sell_once

  <span class="org-comment-delimiter"># </span><span class="org-comment">Now consider a second sale.</span>
  <span class="org-variable-name">max_price_so_far</span> = 0
  <span class="org-keyword">for</span> date, price <span class="org-keyword">in</span> <span class="org-builtin">reversed</span>(<span class="org-builtin">list</span>(<span class="org-builtin">enumerate</span>(prices[2:], 2))):
    <span class="org-keyword">if</span> price &gt;= <span class="org-variable-name">max_price_so_far</span>:
      sell_date = date
      <span class="org-variable-name">max_price_so_far</span> = <span class="org-builtin">max</span>(max_price_so_far, price)

    <span class="org-variable-name">profit_txn2</span> = max_price_so_far - price

    <span class="org-keyword">if</span> profit_txn2 &lt;= 0:
      <span class="org-keyword">continue</span>

    <span class="org-variable-name">max_profit_sell_twice</span> = profit_txn1[date - 1].profit + profit_txn2
    <span class="org-keyword">if</span> max_profit_sell_twice &lt; max_profit:
      <span class="org-keyword">continue</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">If selling once or twice gives us the same profit, then just sell once.</span>
    <span class="org-keyword">if</span> txn1 <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span> <span class="org-keyword">and</span> txn1.profit == max_profit_sell_twice:
      <span class="org-keyword">continue</span>

    max_profit = <span class="org-builtin">max</span>(max_profit, max_profit_sell_twice)
    txn1 = profit_txn1[date - 1]
    txn2 = TXN(date, sell_date, profit_txn2)

  <span class="org-keyword">if</span> txn1 <span class="org-keyword">is</span> <span class="org-constant">None</span>:
    <span class="org-keyword">return</span> <span class="org-constant">None</span>

  <span class="org-keyword">return</span> txn1, txn2
</pre></div></div><p>
In the second pass, we do <code>price &gt;= max_price_so_far</code> instead of the simpler <code>price &gt; max_price_so_far</code> because we want to agree exactly with the brute force approach. For example, consider the case
</p>

<pre class="example" id="org000000d">
1  2  1  1  2  (prices)
0  1  2  3  4  (day number)
</pre>

<p>
Obviously there must be two transactions in order to maximize profit here, buying at price 1 and selling at price 2 (we do this twice). However for the second transaction we could buy at price 1 on day 2 or day 3 &#x2014; the profit at the end is the same. The brute force approach splits into sublists and looks at prices going left to right in both sublists, but for the two-pass algorithm, for the second pass, the prices are looked at right to left. In order to make the two-pass algorithm override its previous choice of day 3 with day 2, we use the <code>&gt;=</code> sign.
</p>
</div>

<div id="outline-container-h-Complexity-1" class="outline-4">
<h4 id="h-Complexity-1"><span class="section-number-4">3.2.1.</span> Complexity</h4>
<div class="outline-text-4" id="text-h-Complexity-1">
<ul class="org-ul">
<li>Time: \(O(n)\), because we have 2 passes, each length \(n\) over the list of prices. Instead of \(2n\) we just have \(n\) because that's how Big-Oh notation works.</li>
<li>Space: \(O(n)\), because we have to create a new array, <code>profit_txn1</code>, which is equal to the size of the list of prices.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-h-Single-pass-algorithm" class="outline-3">
<h3 id="h-Single-pass-algorithm"><span class="section-number-3">3.3.</span> Single-pass algorithm</h3>
<div class="outline-text-3" id="text-h-Single-pass-algorithm">
<p>
This algorithm only requirse a single pass, and also only uses \(O(1)\) space complexity, improving on the two-pass algorithm (<a href="#citeproc_bib_item_2">eefiasfira (https://cs.stackexchange.com/users/107747/eefiasfira), n.d.</a>). It is able to do this by keeping track of three maximum values. It is slightly different than the style of solutions we've looked at so far because it does not keep track of the buy and sell dates.
</p>

<p>
The key is to assume that a second buy has occurred at some previous iteration, and then to see how much profit we can make after a second sale if we assume that we can sell for a second time today (in the current iteration).
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Tests">buy_sell_twice</a></span>(6/6) <span class="lilac-caption-link-symbol"><a href="#__NREF__buy_sell_twice-6">&#x1f517;</a></span></div><pre class="src src-python" id="__NREF__buy_sell_twice-6"><span class="org-keyword">def</span> <span class="org-function-name">single_pass_maybe_sell_twice</span>(prices: <span class="org-builtin">list</span>[<span class="org-builtin">int</span>]
  ) -&gt; Optional[<span class="org-builtin">int</span>]:
  <span class="org-keyword">if</span> <span class="org-builtin">len</span>(prices) &lt; 2:
    <span class="org-keyword">return</span> <span class="org-constant">None</span>

  <span class="org-variable-name">min_price_so_far</span> = <span class="org-builtin">float</span>(<span class="org-string">'inf'</span>)
  <span class="org-variable-name">max_profit_after_first_sell</span> = 0
  <span class="org-variable-name">max_profit_after_second_buy</span> = <span class="org-builtin">float</span>(<span class="org-string">'-inf'</span>)
  <span class="org-variable-name">max_profit_after_second_sell</span> = 0

  <span class="org-keyword">for</span> price <span class="org-keyword">in</span> <span class="org-variable-name">prices</span>:
    min_price_so_far = <span class="org-builtin">min</span>(price, min_price_so_far)
    <span class="org-variable-name">max_profit_after_first_sell</span> = <span class="org-builtin">max</span>(
      <span class="org-builtin">int</span>(price - min_price_so_far),
      max_profit_after_first_sell)
    <span class="org-variable-name">max_profit_after_second_buy</span> = <span class="org-builtin">max</span>(
      max_profit_after_first_sell - price,
      max_profit_after_second_buy)
    <span class="org-variable-name">max_profit_after_second_sell</span> = <span class="org-builtin">max</span>(
      <span class="org-builtin">int</span>(price + max_profit_after_second_buy),
      max_profit_after_second_sell)

  <span class="org-keyword">if</span> max_profit_after_second_sell:
    <span class="org-keyword">return</span> max_profit_after_second_sell

  <span class="org-keyword">return</span> <span class="org-constant">None</span>
</pre></div></div><p>
Variables <code>min_price_so_far</code> and <code>max_profit_after_first_sell</code> are the essentially the same variables used in the optimum solution for <a href="file:///Users/l/prog/codex/problem/buy_sell_stock_once/README.html">"Buy and sell stock once"</a>.
</p>

<p>
Variable <code>max_profit_after_second_buy</code> will only track the cheapest price available while still assuming the context of <code>max_profit_after_first_sell</code>. It's like tracking a second minimum price value (for the best value for the second buy), except that we track the <i>maximum</i> (leftover) profit to be made. The corresponding <code>max_profit_after_second_sell</code> variable just checks what the total profit would be assuming a second sale; the neat thing is that it already has the profits from the first sale accounted for.
</p>

<p>
One difference with this algorithm than the other approaches we've seen so far is that it considers selling stock on the same day that it bought stock.
</p>

<p>
You may also be wondering if it is possible to tweak this algorithm to keep track of the buy and sell dates (as we have done in the other algorithms). This is not possible. For example, consider the following input: <code>[3, 4, 2, 5, 1, 6]</code>. When we see the price at 1, we will set this as the new <code>min_price_so_far</code>. However by setting this value, we make this the date of the first buy date (as it is used for calculating <code>max_profit_after_first_sell</code>), which is wrong (it should be the second buy date).
</p>
</div>

<div id="outline-container-h-Complexity-2" class="outline-4">
<h4 id="h-Complexity-2"><span class="section-number-4">3.3.1.</span> Complexity</h4>
<div class="outline-text-4" id="text-h-Complexity-2">
<ul class="org-ul">
<li>Time: \(O(n)\), because we do a single pass over all elements.</li>
<li>Space: \(O(1)\), because we only need to keep track of a fixed number of variables, independent of the size of the list of prices.</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-h-Tests" class="outline-2">
<h2 id="h-Tests"><span class="section-number-2">4.</span> Tests</h2>
<div class="outline-text-2" id="text-h-Tests">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">Tests</label><span class="lilac-caption-link-symbol"><a href="#Tests">&#x1f517;</a></span></div><pre class="src src-python" id="Tests"><span class="org-keyword">from</span> hypothesis <span class="org-keyword">import</span> given, strategies <span class="org-keyword">as</span> st
<span class="org-keyword">import</span> unittest

<span class="org-keyword">from</span> typing <span class="org-keyword">import</span> Optional

<span class="lilac-child-link-from-parent"><a href="#__NREF__buy_sell_twice-1">buy_sell_twice</a></span>

<span class="org-keyword">class</span> <span class="org-type">Test</span>(unittest.TestCase):
  <span class="org-variable-name">cases</span> = [
    ([],                          <span class="org-constant">None</span>),
    ([0],                         <span class="org-constant">None</span>),
    ([0, 0, 0, 0],                <span class="org-constant">None</span>),
    ([3, 2, 1],                   <span class="org-constant">None</span>),
    ([5, 25, 100, 50],            (TXN(0, 2, 95), <span class="org-constant">None</span>)),
    ([5, 25, 100, 1, 50, 99],     (TXN(0, 2, 95), TXN(3, 5, 98))),
    ([1, 2, 3, 4, 5, 1, 5, 1, 4], (TXN(0, 4, 4),  TXN(5, 6, 4))),
    ([1, 3, 2, 1, 3],             (TXN(0, 1, 2),  TXN(3, 4, 2))),
    ([1, 2, 1, 1, 2],             (TXN(0, 1, 1),  TXN(2, 4, 1))),
    ([1, 1, 1, 2],                (TXN(0, 3, 1),  <span class="org-constant">None</span>)),
    ([1, 2, 2, 3],                (TXN(0, 3, 2),  <span class="org-constant">None</span>)),
    ([3, 5, 2, 1, 3],             (TXN(0, 1, 2),  TXN(3, 4, 2))),
    ([3, 4, 2, 5, 1, 6],          (TXN(2, 3, 3),  TXN(4, 5, 5))),
  ]

  <span class="org-keyword">def</span> <span class="org-function-name">test_simple_cases</span>(<span class="org-keyword">self</span>):
    <span class="org-keyword">for</span> given_prices, expected <span class="org-keyword">in</span> <span class="org-keyword">self</span>.cases:
      <span class="org-keyword">self</span>.assertEqual(brute_force_maybe_sell_twice(given_prices), expected,
                       msg=f<span class="org-string">'</span>{given_prices=}<span class="org-string">'</span>)
      <span class="org-keyword">self</span>.assertEqual(two_pass_maybe_sell_twice(given_prices), expected,
                       msg=f<span class="org-string">'</span>{given_prices=}<span class="org-string">'</span>)

  <span class="org-type">@given</span>(st.lists(st.integers(min_value=1, max_value=100), min_size=0, max_size=14))
  <span class="org-keyword">def</span> <span class="org-function-name">test_random</span>(<span class="org-keyword">self</span>, given_prices: <span class="org-builtin">list</span>[<span class="org-builtin">int</span>]):
    got_sell_once = brute_force(given_prices)
    got_maybe_sell_twice = brute_force_maybe_sell_twice(given_prices)

    <span class="org-comment-delimiter"># </span><span class="org-comment">If we say that we should buy/sell twice, then it must be because we can</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">make more money than buying and selling only once.</span>
    <span class="org-keyword">if</span> (got_sell_once <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>
        <span class="org-keyword">and</span> got_maybe_sell_twice <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>
        <span class="org-keyword">and</span> got_maybe_sell_twice[0] <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>
        <span class="org-keyword">and</span> got_maybe_sell_twice[1] <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>):
      <span class="org-keyword">self</span>.assertGreater(
        got_maybe_sell_twice[0].profit + got_maybe_sell_twice[1].profit,
        got_sell_once.profit)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Check that the other solutions agree with brute force.</span>
    <span class="org-keyword">self</span>.assertEqual(two_pass_maybe_sell_twice(given_prices),
                     got_maybe_sell_twice)

    <span class="org-keyword">if</span> (got_maybe_sell_twice <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>
        <span class="org-keyword">and</span> got_maybe_sell_twice[0] <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>
        <span class="org-keyword">and</span> got_maybe_sell_twice[1] <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>):
      <span class="org-keyword">self</span>.assertEqual(single_pass_maybe_sell_twice(given_prices),
                       got_maybe_sell_twice[0].profit +
                       got_maybe_sell_twice[1].profit )

<span class="org-keyword">if</span> <span class="org-builtin">__name__</span> == <span class="org-string">"__main__"</span>:
  unittest.main(<span class="org-constant">exit</span>=<span class="org-constant">False</span>)
</pre></div></div>
</div>
</div>

<div id="outline-container-h-References" class="outline-2">
<h2 id="h-References"><span class="section-number-2">5.</span> References</h2>
<div class="outline-text-2" id="text-h-References">
<style>.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}</style><div class="csl-bib-body">
  <div class="csl-entry"><a id="citeproc_bib_item_1"></a>Aziz, A., Lee, T.-H., &#38; Prakash, A. (2018). <i>Elements of Programming Interviews in Python: The Insidersâ€™ Guide</i>. CreateSpace Independent Publishing Platform (25 July. 2018).</div>
  <div class="csl-entry"><a id="citeproc_bib_item_2"></a>eefiasfira (https://cs.stackexchange.com/users/107747/eefiasfira). (n.d.). <i>O(1) space, O(N) complexity algorithm for buy and sell stock twice interview question</i>. Computer Science Stack Exchange. <a href="https://cs.stackexchange.com/q/112007">https://cs.stackexchange.com/q/112007</a></div>
</div>
</div>
</div>
</div>
</body>
</html>
